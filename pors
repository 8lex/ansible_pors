#!/bin/bash
########################################################################################
## @file	pors.sh
## @brief       PORS is an UI for managing your whole Splunk infrastructure with Ansible
## @author	Thomas Fischer <mail -AT- sedi -DOT- one>
## @date        2017-2021
## @copyright	AGPL v3
## @details     
##    This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU Affero General Public License as
##    published by the Free Software Foundation, either version 3 of the
##    License, or (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU Affero General Public License for more details.
##
##    You should have received a copy of the GNU Affero General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.
##
########################################################################################
#
## @mainpage Playbooks-On-Rails for Splunk (PORS)
## @section intro Overview
## Playbooks-On-Rails for Splunk (PORS) is a wrapper and GUI (ncurses/dialog based) to execute several tasks with ansible.<br>
## This is a pure **technical** documentation of PORS for those who want to understand how it works under the hood
##
## @section code Code
## PORS is hosted at github:<br>
## https://github.com/secure-diversITy/ansible_pors
## 
## @section secintro User documentation
## Playbooks-On-Rails for Splunk (PORS) configuration and installation is described here: <br>
## https://github.com/secure-diversITy/ansible_pors/wiki
##<br>
###############################################################################################################
VERSIONTYPE=beta
VERSIONNUM="4.0-17"
VERSION="${VERSIONNUM}-${VERSIONTYPE}"
###############################################################################################################
#
# This script can be automatically documented by doxygen (http://doxygen.nl)
#
# There are a few things you have to do so though:
# - every var must be exported or declared to get identified properly
# - every function must start like that: "<name>(){ <EOL>" 
#   So func name, brackets and { must be all in the same line and you have to start code at the next line first.
# - bash advanced if-var-empty syntax like: ': "${DEFSPLAPIADMIN:=admin}"' won't get detected, 
#   use test -z and declare instead
#
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
##############################################################################################################

## @var NCURSES_NO_UTF8_ACS
## @brief ensure PuttY will not look ugly
export NCURSES_NO_UTF8_ACS=1

###############################################################################
# Do NOT change variables here! 
###############################################################################
# all user variables can and have to be set here:
#
# --> ${HOME}/.pors/vars
#
# init that file with:
# cp EXAMPLES/.pors_vars-example ${HOME}/.pors/vars
#
# then modify ${HOME}/.pors/vars to your needs
#
###############################################################################

# source an variable overwrite if available
[ -f ${HOME}/.pors/vars ] && source ${HOME}/.pors/vars

# DEBUG mode (1) or not (0)
: "${DEBUG:=0}"

[ $DEBUG -eq 1 ] && echo "DEBUG MODE ON !!!!"

## @var RUNMODE
## @brief PORS can run in several modes this sets the default
## @showinitializer
## @details There is *no* (!) need to touch this as it will be adjusted depending
## on the parameters how PORS is started (e.g. --batch will set batch mode)
export RUNMODE="interactive"

## @var OS_SERVICE_USER
## @brief An (optional) service account username
## @showinitializer
## @details This account will be added when installing a new VM only.
## So on a new VM deployment this user will be created and given root
## permissions. The if empty check must exists to make it appear in the doc..
[ -z "${OS_SERVICE_USER}" ] && \
export OS_SERVICE_USER=

## @var PYTHONUNBUFFERED
## @brief avoid buffering when exec python code (ansible)
## @showinitializer
## @details when python buffers output PORS seems to hang until the 
## whole playbook has been finished without any feedback. This ensures we see output directly in PORS.
export PYTHONUNBUFFERED=1

## @var BIN
## @brief auto generate the binary name without path
## @showinitializer
declare BIN=${0##*/}

## @var REQAVERSION
## @brief The minimal required Ansible version
## @details the version string in the format: X.x.x
## @showinitializer
declare REQAVERSION="2.8.0"

# ensure we run in a proper environment
if [ -z "$CALLUSR" ];then
    MYHOME=${HOME}/.$(echo ${BIN/.sh}|tr -d _)
else
    MYHOME=/tmp/pors-${CALLUSR}
fi

## @var WORKDIR
## @brief The working directory where all run files will be stored
## @details Every user has its own temp directory accessible only by the PORS user
## @showinitializer
declare WORKDIR="$MYHOME"
[ ! -d "$WORKDIR" ]&& mkdir -p $WORKDIR
chown $USER $WORKDIR
chmod 700 $WORKDIR  

## @var ADIR
## @brief auto generate the path name of the bin
## @showinitializer
## @details the PORS install dir. can be overwritten in ~/.pors/vars 
[ -z "$ADIR" ] && \
declare ADIR="${0%/*}"

## @var DATADIR
## @brief the PORS data directory 
## @showinitializer
## @details the PORS data dir. can be overwritten in ~/.pors/vars
[ -z "$DATADIR" ] && \
declare DATADIR="/opt/pors_data"

## @var AINVENTORY
## @brief Ansible inventories directory
## @showinitializer
## @details the PORS inventories dir.
## the place where your Ansible inventories (with their subdirs like development, production) are in.
## also includes app links etc. should be overwritten in ~/.pors/vars for production use.
[ -z "$AINVENTORY" ] && \
declare AINVENTORY="$DATADIR/inventories"

## @var KICKUSER
## @brief Default setting for overtaken a running session
## @showinitializer
## @details normally we want to have 1 instance running the same time. This avoids dozens of problems which could occur.
## The default when pressing just enter can be y (remove and take the lock) or N (quit)
declare KICKUSER=N

## @var ABIN
## @brief The full path to the regular ansible playbook binary
## @showinitializer
[ -z "$ABIN" ] && \
declare ABIN="/usr/bin/ansible-playbook"

## @var VBIN
## @brief The full path to the regular ansible-vault binary
## @showinitializer
[ -z "$VBIN" ] && \
declare VBIN="/usr/bin/ansible-vault"

# if you want you can run another ansible version by specifying the A2xx vars:
: "${A2PATH:=/usr/bin}"
: "${A2BIN:=$A2PATH/ansible-playbook}"

## @var LOGDIR
## @brief The log directory
## @showinitializer
[ -z "$LOGDIR" ] && \
declare LOGDIR=${WORKDIR}/logs

## @var LOG
## @brief The log file
## @showinitializer
declare LOG=${LOGDIR}/$(date +%F_%H-%M)_${BIN}.log

## @var MAXLOG
## @brief How many log files are allowed before rotate starts
## @showinitializer
[ -z "$MAXLOG" ] && \
declare MAXLOG=3

## @var AEUSRHOSTFILE
## @brief the user choosen hostfile will be written into this file
## @details can be sourced like: source $AEUSRHOSTFILE - will set HOSTFILE=
## @showinitializer
declare AEUSRHOSTFILE=${WORKDIR}/ae_current_hostfile

## @var EDITBIN
## @brief The editor which will be used e.g. when editing system/local files
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$EDITBIN" ] && \
declare EDITBIN=/usr/bin/vim

## @var PBDIR
## @brief The directory where all playbooks are expected (base path)
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$PBDIR" ] && \
declare PBDIR="$ADIR/playbooks"

## @var PBDIRCRIBL
## @brief The directory where all CRIBL playbooks are expected
## @details playbooks for CRIBL logstream
## @showinitializer
[ -z "$PBDIRCRIBL" ] && \
declare PBDIRCRIBL="$PBDIR/cribl"

## @var PBDIRSHELPER
## @brief The directory where all shelper playbooks are expected
## @details playbooks for splunk shelper
## @showinitializer
[ -z "$PBDIRSHELPER" ] && \
declare PBDIRSHELPER="$PBDIR/shelper"

## @var PBDIRSPLUNK
## @brief The directory where all splunk playbooks are expected
## @details playbooks for splunk
## @showinitializer
[ -z "$PBDIRSPLUNK" ] && \
declare PBDIRSPLUNK="$PBDIR/splunk"

## @var PBDIRVMWARE
## @brief The directory where all vmware playbooks are expected
## @details playbooks for VMware
## @showinitializer
[ -z "$PBDIRVMWARE" ] && \
declare PBDIRVMWARE="$PBDIR/vmware"

## @var PBDIRSYSTEM
## @brief The directory where all system playbooks are expected
## @details playbooks for System
## @showinitializer
[ -z "$PBDIRSYSTEM" ] && \
declare PBDIRSYSTEM="$PBDIR/system"

## @var PBDIRGOOGLECP
## @brief The directory where all GCP playbooks are expected
## @details playbooks for Google Cloud Platform (GCP)
## @showinitializer
[ -z "$PBDIRGOOGLECP" ] && \
declare PBDIRGOOGLECP="$PBDIR/googlecp"

## @var PBDIRPROXMOX
## @brief The directory where all PVE playbooks are expected
## @details playbooks for Proxmox VE (PVE)
## @showinitializer
[ -z "$PBDIRPROXMOX" ] && \
declare PBDIRPROXMOX="$PBDIR/proxmox"

## @var ROLEDIR
## @brief The directory where all roles are expected
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$ROLEDIR" ] && \
declare ROLEDIR="$ADIR/roles"

## @var PBENAPP
## @brief Adding/Linking new app(s) to PORS
## @showinitializer
declare PBENAPP=${PBDIRSPLUNK}/ae_enable_app.yml

## @var PBREGENDEPLOY
## @brief Regenerate ae_deploy_apps.yml
## @showinitializer
## @details This playbook generates $PBDEPLAPP based on the linked apps<-->targets
declare PBREGENDEPLOY=${PBDIRSPLUNK}/ae_recreate_deploy.yml

## @var PBDEPLAPP
## @brief Deploy apps to given targets
## @showinitializer
## @details This playbook gets autogenerated when running $PBREGENDEPLOY
declare PBDEPLAPP=ae_deploy_apps.yml

## @var PBDEPLSYSC
## @brief Deploy system/local configs to given targets 
## @showinitializer
declare PBDEPLSYSC=${PBDIRSPLUNK}/ae_deploy_systemconfigs.yml

## @var PBGETTARGETS
## @brief Parsing inventories file and create an expanded host list for each target
## @showinitializer
declare PBGETTARGETS=${PBDIRSPLUNK}/ae_get_targets.yml

## @var PBUPGRADE
## @brief Upgrade splunk
## @showinitializer
declare PBUPGRADE=${PBDIRSPLUNK}/ae_upgrade_splunk.yml

## @var  PBSHINSTALL
## @brief Install/Upgrade the splunk helper
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHINSTALL=${PBDIRSHELPER}/ae_install_shelper.yml

## @var SHOWAPPS
## @brief Show app deployment state by target(s) and type (local, git, ...)
## @showinitializer
declare SHOWAPPS=${ADIR}/ae_show_app_deploymentstate.sh

## @var PBSHRELOAD
## @brief Execute splunk helper tasks
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHRELOAD=${PBDIRSYSTEM}/ae_shelper_reload.yml

## @var PBSPLACT
## @brief Maintenance tasks for splunk
## @details Examples: splunk stop, start, restart
## @showinitializer
declare PBSPLACT=${PBDIRSPLUNK}/splunk_actions.yml

## @var PBINSTALL
## @brief Install splunk
## @details Will install splunk on a single host or group of hosts
## @showinitializer
declare PBINSTALL=${PBDIRSPLUNK}/ae_install_splunk.yml

## @var PBINSTALLLOGSTREAM
## @brief Install cribl logstream
## @details Will install cribl logstream on a single host or group of hosts
## @showinitializer
declare PBINSTALLLOGSTREAM=${PBDIRCRIBL}/ae_install_logstream.yml

## @var PBCONFMN
## @brief Configures splunk as a master node
## @details This will configure an existing splunk installation as a MasterNode for a new cluster
## @showinitializer
declare PBCONFMN=${PBDIRSPLUNK}/ae_configure_masternode.yml

## @var PBCONFLM
## @brief Configures splunk as a license master
## @details This will configure an existing splunk installation as a LicenseMaster
## @showinitializer
declare PBCONFLM=${PBDIRSPLUNK}/configure_licensemaster.yml

## @var PBCONFDS
## @brief Configures splunk as a deploymentserver
## @details This will configure an existing splunk installation as a DeploymentServer
## @showinitializer
declare PBCONFDS=${PBDIRSPLUNK}/configure_deploymentserver.yml

## @var PBCONFMC
## @brief Configures splunk as a Monitoring Console
## @details This will configure an existing splunk installation as a MonitoringConsole
## @showinitializer
declare PBCONFMC=${PBDIRSPLUNK}/configure_monitoringconsole.yml

## @var PBDEPLMONKEY
## @brief Deploys the MonitoringConsole key for monitoring given targets
## @showinitializer
declare PBDEPLMONKEY=${PBDIRSPLUNK}/deploy_monitoringkeys.yml

## @var PBCONFMONROLES
## @brief (Re-)configure the MonitoringConsole roles
## @showinitializer
declare PBCONFMONROLES=${PBDIRSPLUNK}/configure_monitoringroles.yml

## @var PBCONFPEER
## @brief Configures splunk as a peernode 
## @details This will configure an existing splunk installation as a peernode of an existing indexer cluster
## @showinitializer
declare PBCONFPEER=${PBDIRSPLUNK}/ae_configure_ix_peernode.yml

## @var PBCONFSHCM
## @brief Configures splunk as a SHC member
## @details This will configure an existing splunk installation as a SHC member
## @showinitializer
declare PBCONFSHCM=${PBDIRSPLUNK}/configure_shcmember.yml

## @var PBCONFSH
## @brief Configures splunk as a searchhead
## @details This will configure an existing splunk installation as a SearchHead
## @showinitializer
declare PBCONFSH=${PBDIRSPLUNK}/ae_configure_searchhead.yml

## @var PBCONFDEP
## @brief Configures splunk as a SHC deployer
## @details This will configure an existing splunk installation as a Deployer
## @showinitializer
declare PBCONFDEP=${PBDIRSPLUNK}/configure_deployer.yml

## @var PBCONFHF
## @brief Configures splunk as a heavy forwarder
## @details This will configure an existing splunk installation as a Heavy Forwarder
## @showinitializer
declare PBCONFHF=${PBDIRSPLUNK}/ae_configure_heavyforwarder.yml

## @var INSTDEF
## @brief splunk installation conf
## @details Used to configure several splunk installation relevant stuff like tgz/rpm/version etc
## @showinitializer
declare INSTDEF=splunk_installation.yml

## @var PBDLSPL
## @brief Downloader for splunk tar's
## @details Will download a defined splunk release (hard coded type: linux/64bit/tar.gz) directly from splunk
## @showinitializer
declare PBDLSPL=${PBDIRSPLUNK}/ae_download_splunk.yml 

## @var PBVCINFO
## @brief Collecting vCenter information
## @details Will connect to a vCenter and grabs all relevant information for VM deployment
## @showinitializer
declare PBVCINFO="${PBDIRVMWARE}/vcenter_get-info.yml"

## @var PBVCGETVHOSTSTATES
## @brief Collecting / Refreshing vhost conenction states
## @details Will connect to a vCenter and re-evaluates the states for each connected vhost (ESX)
## @showinitializer
declare PBVCGETVHOSTSTATES="${PBDIRVMWARE}/vcenter_get-vhoststates.yml"

## @var PBVCVMDEPLOY
## @brief Deploys a VM over a given vCenter to a ESX host
## @details Will connect to a vCenter and deploys a new VM to it (based on a given template)
## @showinitializer
declare PBVCVMDEPLOY="${PBDIRVMWARE}/vcenter_deploy-vm.yml"

## @var PBVCSHOW
## @brief Parse and show all local defined vCenters
## @details vCenter definitions are taken in:
## $INVENTORY/$TARGETENV/group_vars/all/bare_install
## The playbook $PBVCSHOW will parse and write the results to a tmp file defined in $PBVCSHOW
## @showinitializer
declare PBVCSHOW="${PBDIRVMWARE}/vcenter_show-avail.yml"

## @var PBVMNEWDISK
## @brief Add an additional disk to an existing VM
## @details ..
## @showinitializer
declare PBVMNEWDISK="${PBDIRVMWARE}/ae_vm_add-new-disk.yml"

## @var PBVMDISKFORMAT
## @brief Formatting a given disk in a VM
## @details ..
## @showinitializer
declare PBVMDISKFORMAT="${PBDIRVMWARE}/ae_vm_format-new-disk.yml"

## @var PBPVEDEPLOY
## @brief Deploys a VM to Proxmox
## @details Will connect to a Proxmox Node and deploys a new VM to it (based on a given template)
## @showinitializer
declare PBPVEDEPLOY="${PBDIRPROXMOX}/px_create_vm.yml"

## @var PBPVEGETNODES
## @brief Get configured PVE nodes
## @details Get configured Proxmox Nodes from the ansible config
## @showinitializer
declare PBPVEGETNODES="${PBDIRPROXMOX}/px_get_nodes.yml"

## @var PBGCPGETIDS
## @brief Get configured GCP project ids
## @details Get configured Google Cloud Platform project ids from the ansible config
## @showinitializer
declare PBGCPGETIDS="${PBDIRGOOGLECP}/gcp_get_ids.yml"

## @var PBGCPDEPLOY
## @brief Deploy GCP instance(s)
## @details Deploy a Google Cloud Platform (GCP) instance (including configuration)
## @showinitializer
declare PBGCPDEPLOY="${PBDIRGOOGLECP}/gcp_deploy_instance.yml"

## @var PBSYSDISKFORMAT
## @brief Formats a disk
## @details Formats an existing (!) disk
## @showinitializer
declare PBSYSDISKFORMAT="${PBDIRSYSTEM}/disk_format.yml"

## @var PBBASEINSTALL
## @brief setup the default base of a deployed system
## @details El-Repo kernel and system upgrades are just 2 examples here
## @showinitializer
declare PBBASEINSTALL="${PBDIRSYSTEM}/ae_system_base.yml"

## @var PBSYSKERNEL
## @brief Install/Set/Update the kernel
## @details El-Repo kernel
## @showinitializer
declare PBSYSKERNEL="${PBDIRSYSTEM}/ae_system_kernel.yml"

## @var PBSYSUPGRADE
## @brief System Upgrade
## @details Refreshes cache DB and starting a full system upgrade
## @showinitializer
declare PBSYSUPGRADE="${PBDIRSYSTEM}/ae_system_upgrade.yml"

## @var PBSSHCHK
## @brief Initial SSH connect
## @details Will add the host key when none exists yet. Add will be skipped when a host key changed!
## @showinitializer
declare PBSSHCHK="${PBDIRSYSTEM}/ae_ssh.yml"

## @var PBSYSREBOOT
## @brief general system reboot (linux)
## @details reboots a remote system
## @showinitializer
declare PBSYSREBOOT="${PBDIRSYSTEM}/ae_system_reboot.yml"

## @var PBCREATEUSER
## @brief Playbook for creating a linux user
## @showinitializer
declare PBCREATEUSER="${PBDIRSYSTEM}/ae_create_useracc.yml"

## @var PBDEPLOYKEY
## @brief Playbook for deploying a splunk pub key
## @showinitializer
declare PBDEPLOYKEY="${PBDIRSYSTEM}/deploy_splunk_pubpem.yml"

## @var DEFSPLAPIADMIN
## @brief default splunk API (target:8089) admin account
## @details Defaults to "admin" user and can be changed interactively in PORS when asked.
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## This account needs privileges to run API calls so either the admin or an user with at least the following capabilities (not tested and so maybe incomplete):
## - rest_apps_view
## - rest_properties_get
## - rest_properties_set
## - restart_splunkd
## @showinitializer
[ -z "$DEFSPLAPIADMIN" ] && \
declare DEFSPLAPIADMIN=admin

## @var DEFHOSTFILE
## @brief default filename for host/group definitions in ansible
## @details Defaults to "hosts" and can be changed interactively in PORS when asked.
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
[ -z "$DEFHOSTFILE" ] && \
declare DEFHOSTFILE=hosts

## @var GLABSETTINGS
## @brief gitlab authentication file
## @details stores the gitlab token for communicationg with gitlab API
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
[ -f "${HOME}/.pors/gitlab.auth" ] && GLABSETTINGS="${HOME}/.pors/gitlab.auth"
[ -z "$GLABSETTINGS" ] && \
declare GLABSETTINGS="$WORKDIR/gitlab.auth"

## @var AEUSER
## @brief local username for running PORS
## @details Defaults to "splunk" as it is meant for multi-user environments to keep track of actions in PORS. 
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
#: "${AEUSER:=splunk}"
[ -z "$AEUSER" ] && \
declare AEUSER=pors

## @var ENABLEVAULT
## @brief Make use of the Ansible Vault
## @details When set to "yes" PORS will ask for the Vault password on certain actions
## hint: to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
[ -z "$ENABLEVAULT" ] && \
declare ENABLEVAULT=yes

## @var SESSIONBASEDVAULT
## @brief Store the Ansible Vault temp file for the whole session
## @details When set to "yes" PORS will not remove the temporary Vault password (req: ENABLEVAULT=yes)
## for the whole session (less questions but less secure). When PORS ends it will be deleted of course.
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
[ -z "$SESSIONBASEDVAULT" ] && \
declare SESSIONBASEDVAULT=yes

## @var DEFAULTVAULT
## @brief full path to the default vault
## @details This is used to check the typed password so it must exists (if using ENABLEVAULT=yes)
## @showinitializer
[ -z "$DEFAULTVAULT" ] && \
declare DEFAULTVAULT=$AINVENTORY/$TARGETENV/group_vars/all/vault.yml

#################################################################################################
# NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT 
#################################################################################################

# test all playbooks
# gen: egrep '^declare \w+=|^export \w+=' pors |cut -d = -f1 |grep PB | cut -d " " -f2 | sed 's/^/$/g' | egrep -v "DIR|PBDEPLAPP" |tr "\n" " "
PBS="$PBENAPP $PBREGENDEPLOY $PBDEPLSYSC $PBGETTARGETS $PBUPGRADE $PBSHINSTALL $PBSHRELOAD $PBSPLACT $PBINSTALL $PBINSTALLLOGSTREAM $PBCONFMN $PBCONFPEER $PBCONFSH $PBCONFHF $PBDLSPL $PBVCINFO $PBVCGETVHOSTSTATES $PBVCVMDEPLOY $PBVCSHOW $PBVMNEWDISK $PBVMDISKFORMAT $PBBASEINSTALL $PBSYSKERNEL $PBSYSUPGRADE $PBSSHCHK $PBSYSREBOOT $PBCREATEUSER"

for pb in $PBS;do
    #find $PBDIR -name ${pb/*\/}
    [ ! -f $pb ] && echo "ERROR: playbook missing: $pb" && exit 3 
done

## @var VAULTTEMPFILE
## @brief The temporary file holding the Ansible Vault password
## @details Only relevant if ENABLEVAULT is set to yes.
## to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do *not* set ENABLEVAULT=yes .
## The temporary file is placed in WORKDIR which is accessible by the PORS user only!
declare VAULTTEMPFILE="${WORKDIR}/.avtmp"

## @fn F_LOG()
## @brief Logging function
## @param 1 (required) the calling parent function
## @param 2 (required) the message to be logged
## @details Logging function
F_LOG(){
    [ ! -d $LOGDIR ] && mkdir -p $LOGDIR
    CALLER="$1"
    MSG="$2"
    if [ -z "$MSG" ]||[ -z "$CALLER" ];then
    	F_DIAERR 2 "INTERNAL ERROR: $FUNCNAME requires an arg"
    else
    	PREFIX="$(date '+%F_%T') - PORS - ($CALLER) -"
        echo -e "$PREFIX $MSG" >> $LOG
    fi
}

## @fn F_LOGROTATE()
## @brief Rotates the PORS log
## @details Rotates the PORS log
F_LOGROTATE(){
    ROTATE=no

    CURLOGCNT=$(find $LOGDIR -type f | wc -l)
    while [ "$CURLOGCNT" -gt $MAXLOG ];do
        ROTATE=yes
        CURLOGCNT=$(find $LOGDIR -type f | wc -l)
        OLDESTLOG=$(find $LOGDIR -type f -printf '%T+ %p\n' | sort | head -n 1)
        rm $OLDESTLOG 
    done

    echo "Starting new log - $(date +%Y-%m-%d_%T) - version: $VERSION" > $LOG
    F_LOG $FUNCNAME "log has been rotated: $ROTATE"
}

## @fn F_RMVAULTPW()
## @brief removes the temporary Ansible Vault pw file
## @param 1 (optional) force/override SESSIONBASEDVAULT setting
## @details Checks for $VAULTTEMPFILE and if that exists it gets deleted.
## This should be used whenever F_VAULTPW was used before.
F_RMVAULTPW(){
    F_LOG $FUNCNAME started
    if [ -f "$VAULTTEMPFILE" ];then
        [ $DEBUG -eq 1 ] &&  F_LOG $FUNCNAME "DEBUG MODE !!! DEBUG MODE !!! skipped removing vault temp file forever!" && return 0
        [ ! -z $STEALTHMODE ] && F_LOG $FUNCNAME "skipped removing vault temp file as we are in STEALTH mode!" && return 0
        [ "$RUNMODE" == "batch" ] && F_LOG $FUNCNAME "skipped removing vault temp file as we are in BATCH mode!" && return 0
        [ "$1" == "force" ] && F_LOG $FUNCNAME "deleting vault temp file - forced" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" != "yes" ] && F_LOG $FUNCNAME "deleting vault temp file - regular" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" == "yes" ] && F_LOG $FUNCNAME "skipped removing vault temp file" && return 0
        F_LOG $FUNCNAME "deleting vault temp file - no SESSIONBASEDVAULT" && rm $VAULTTEMPFILE
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_ENDSESS()
## @brief Clear session
## @details PORS ensures it will not be executed more then 1 time by the EXECBIT var
F_ENDSESS(){
    F_LOG $FUNCNAME started
    if [ -z $STEALTHMODE ]||[ "$RUNMODE" != "batch" ];then
        F_RMVAULTPW force
    fi
    [ -z $STEALTHMODE ] && F_LOG $FUNCNAME "deleting session file:" && rm -vf $EXECBIT 2>&1 >> $LOG
    F_LOG $FUNCNAME ended
}

## @fn F_EXIT()
## @brief regular PORS exit
## @details clean exit including clearing the session bit
F_EXIT(){
    F_LOG $FUNCNAME "started with $1"
    ERRCODE=$1

    F_ENDSESS
    # finally terminate
    F_LOG $FUNCNAME "ended with code $ERRCODE" 
    exit $ERRCODE
}

## @fn F_EXITUNCLEAN()
## @brief exit the program unclean but controlled
## @param 1 optional: exit code (default 0)
## @details will not clear the session bit so only needed in rare cases (e.g. --help)
F_EXITUNCLEAN(){
    F_LOG $FUNCNAME started
    ERRCODE=$1
    echo "$FUNCNAME: No session exit" >> $LOG
    F_LOG $FUNCNAME "ended $ERRCODE"
    #trap - SIGINT SIGHUP TERM
    exit $ERRCODE
}

# catch ctrl+c, kills etc to terminate cleanly..
trap F_EXIT SIGINT SIGHUP TERM

# check requirements first
dialog --version >> /dev/null 2>&1
if [ $? -ne 0 ];then
	echo -e "\nplease install the software <dialog> first!\n"
else
    $ABIN --version >> /dev/null 2>&1
    if [ $? -ne 0 ];then
        echo -e "\nReally?? You want to use ansible deployment without ansible??! Coooool.. Install ansible and try again..\n"
	export ERRCODE=90
        F_EXIT
    fi
    for i in $(echo $SHOWAPPS $PBNEWAPP $PBENAPP $PBDEPLSYSC);do
	if [ ! -r $i ];then 
	    echo -e "\n\tERROR. Please ensure you've done chmod +r $i first and that $i exists!\n"
	    F_EXIT
	fi
    done
fi

## @fn F_A2BIN()
## @brief start ansible v2 (instead of PATH bin)
## @param 1 (required) the ansible hostfile or the special "version" tag
## @param 2 (required) the ansible playbook
## @param 3 (required) the title for the progressbox of the playbook run
## @param 4 (optional) ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format<br>
## @param 5 (optional) a YAML or json formatted filename containing extra vars
## @details start A2BIN. takes all args without any proof / verification!
## TODO: parse args and do a basic validation?!<br>
## example args: F_A2BIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
F_A2BIN(){
        F_LOG $FUNCNAME started
	# returns error code of the playbook run
	#
	# requires these parameters:
	A2HOSTFILE="$1" # the ansible hostfile or the special "version" tag
	A2PB="$2"	# the ansible playbook
	BOXTITLE="$3"	# the title for the progressbox of the playbook run

	# optional:
	# ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format!!
	# e.g.: F_A2BIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
	A2ARGSRAW="$4"	

        # optional: extra variables defined in a file in YAML/json format
        EVARFILE="$5"

	F_LOG $FUNCNAME "ARGSRAW: $A2ARGSRAW , EVARFILE: $EVARFILE"
	
	# find space keyword
	A2ARGS=$(echo "$A2ARGSRAW" | sed 's/SPACE/ /g')
	F_LOG $FUNCNAME "ARGS: $A2ARGS"
	
        # build 
	if [ -z "$A2HOSTFILE" ]||[ -z "$A2PB" ]||[ ! -f "$A2HOSTFILE" ]||[ ! -f "$A2PB" ];then
            if [ "$A2HOSTFILE" != "version" ];then
	        if [ "$RUNMODE" == "batch" ];then
                    echo "ERROR: Missing or wrong ARGS in $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)!"
                    return 1
                else
                    F_DIAERR 3 "INTERNAL ERROR: Missing or wrong ARGS for $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)"
                fi
	        F_EXIT $FUNCNAME 3
            fi
	fi

	F_LOG $FUNCNAME "$A2BIN -i $A2HOSTFILE ${A2ARGS} $A2PB"
        OLDPP="$PYTHONPATH"
	F_LOG $FUNCNAME "python path before: $OLDPP"
	export PYTHONPATH=${A2PATH}/lib
	F_LOG $FUNCNAME "python path after: $PYTHONPATH"
        if [ "$A2HOSTFILE" == "version" ];then
            $A2BIN --version
            A2ERR=$?
        else
            if [ "$RUNMODE" == "interactive" ];then
                [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
                if [ ! -z "$EVARFILE" ];then
                    F_LOG $FUNCNAME "Will execute:\n$A2BIN -vvv -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} -e @$EVARFILE"
	            $A2BIN -v -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} -e "@${EVARFILE}" 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
                else
                    F_LOG $FUNCNAME "Will execute:\n$A2BIN -vvv -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG}"
	            $A2BIN -v -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
                fi
	        A2ERR="${PIPESTATUS[0]}"
            else
                $A2BIN -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG
	        A2ERR="${PIPESTATUS[0]}"
            fi
        fi
        export PYTHONPATH="$OLDPP"
        F_LOG $FUNCNAME "previous python path restored: $PYTHONPATH"
	F_LOG $FUNCNAME "finished with errcode: $A2ERR"
	return $A2ERR
}

## @fn F_DIALOG()
## @brief main dialog form with PORS presets
F_DIALOG(){
    if [ "$RUNMODE" == "interactive" ];then
	    dialog --no-mouse --title "PORS v$VERSION/$MAXAVERSION (${TARGETENV})" "$@"
    else
        echo "$@"
    fi
}

## @fn F_HELP()
## @brief Usage/Help for PORS
F_HELP(){
cat <<_EOHELP

    USAGE/HELP for $BIN (v$VERSION)

    Interactive / GUI mode:
    ------------------------------------------
    The regular way of using PORS

    --env <environment>                         define the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)
    --help                                      Will show this

    --advanced                                  Will enable/show advanced option menu
    --testing                                   Unfinished menu options
    -i|--inventory <hosts-file>                 The full path to your hosts filename


    Batch / API mode: !!!WORK-IN-PROGRESS!!!
    ------------------------------------------
    Enables full automated way of using PORS

    --batch

     MANDATORY:

       --env <environment>                      define the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)
       -i|--inventory <hosts-file>              The full path to your hosts filename
       -t|--target <targetgroup>                The group name as defined in your inventory

       ACTION OR PLAYBOOK OR FUNCTION (MANDATORY)

       -p|--play <playbookname>                 available playbooks are in $PBDIR
         [--playargs "<arguments>"]             optional variables for the given playbook. must be defined as key=value.

       OR
       -f|--function <function>                 interal $BIN function name (e.g. F_ADDPEER)
         [--funcargs "<arguments>"              optional parameters for the given function

       OR
       -a|--action <predefined action>          current predefined actions are:
                                                - deploy

     OPTIONAL:

       -pa|--post-action <post-action>          The action will be performed on the defined <targetgroup> and the current predefined post-actions are: 
                                                reload-all (like a debug refresh)
                                                DS-reload (reload deploy-server on a deploymentserver)
                                                MN-apply-cb (apply cluster-bundle on a masternode)
                                                SHC-apply-cb (apply shcluster-bundle on a deployer)
       --vault-password-file <secret-file>      If you are using Ansible Vault this setting allows to specify a local file containing the
                                                secret to unlock your vault. This is of course a SECURITY ISSUE but if you using vault vars in your playbooks then
                                                ensure that the file permissions of <secret-file> are as restrictive as possible
       -1                                       will force to use ansible v1 as v2 is default
       --deployapp "<app name(s)>"              QUOTED list separated by a PIPE (|) of app names to deploy - if you do *not* want to deploy ALL apps for a target!
                                                This quoted list is egrep regex so may match unwanted things if not being careful.
                                                Example:
                                                If you set --deployapp "my-app|my-other-app" it will match my-app and my-other-app - but also my-app-bla, my-apps, etc
                                                If you want to ensure that only the name "my-app" matches use the $ char at the end: like --deployapp "my-app$|my-other-app"

_EOHELP
}

## @fn F_SHOWAPPS()
## @brief Deprecated way of parsing and showing apps<->target
## @param 1 The target group to parse for
## @return a list of all apps linked to the target
## @exception if env cant be found
## @details This is superseeded by F_LISTAPPS and should not be used anymore
F_SHOWAPPS(){
	echo "$FUNCNAME started" >> $LOG
	SEL="$1"
	[ -z "$SEL" ]&& echo ERROR missing arg for F_SHOWAPPS
	if [ "$SEL" == "ALL" ];then
		$SHOWAPPS -env $AINVENTORY/$TARGETENV
	else
		$SHOWAPPS -env $AINVENTORY/$TARGETENV "$SEL"
	fi
	echo "************************************************"
	read -p "To continue press ENTER" DUMMY
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_LISTAPPS()
## @brief Parse and show apps<->target links
## @param 1 The target group to parse for
## @return a list of all apps linked to the target in the format: "type:app-name"
## @exception if env cant be found
## @details $SHOWAPPS is able to handle one or multiple targets at the same time
F_LISTAPPS(){
        F_LOG $FUNCNAME started
        SEL="$1"
        [ -z "$SEL" ]&& echo "ERROR:missing arg for $FUNCNAME"
        if [ "$SEL" == "ALL" ];then
                $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV
        else
                $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV "$SEL"
        fi
        F_LOG $FUNCNAME "ended with $?"
}

## @fn F_RMAPP()
## @brief Removes an app <--> target linkage
## @exception abort by user/error on unlinking
## @details Removes an app <--> target linkage
## 1. ask for complete removal or just unlink
## 2. ask for target group
## 3. offer multi checkbox list of all apps for that group
F_RMAPP(){
    F_LOG $FUNCNAME started

    unset SELECTION RMAPPS ABORTED HOSTSELECT HOSTSELECTION
    F_HOSTFILE

    SELECTION=$(F_DIALOG --radiolist "You have to choose an action mode first\n\nThe following will be choosen for ALL apps you will select in the next steps.\n(You can *not* use both modes in the same run)\n\n" 15 150 16 "Remove" "Will completely delete apps (local *AND* on remote)" "on" "Disable" "Will keep the link but disables app from PORS deployment (will *not* touch remote)" "off" "Unlink" "Will completely unlink the apps (will *not* touch remote)" "off" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    while [ -z "$HOSTSELECT" ];do
        HOSTSELECTION=$(F_TARGETS radiolist)
        [ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && return 4
        if [ -z "$HOSTSELECTION" ];then
            F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
        else
            HOSTSELECT=1
            ABORTED=0
        fi
    done
    if [ "$ABORTED" -ne 0 ];then
        F_LOG $FUNCNAME "DEBUG: aborted by user."
        return 4
    fi

    F_LOG $FUNCNAME "Choosen target group: $HOSTSELECTION"
    OPTIONS=($(for i in $(F_LISTAPPS "$HOSTSELECTION" |cut -d ":" -f 1-2);do echo "${i/*:}" "${i/:*}" off;done))
    RMAPPS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    F_LOG $FUNCNAME "choosen apps for deletion: $RMAPPS"
    
    # in any case disable the app locally
    for app in $RMAPPS;do
        sed -i "s/\(^\s*\)\(install:\s*[Tt]rue\)/\1install: false/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>> $LOG
    done

    case $SELECTION in
        Remove)
           for app in $RMAPPS;do
                # ensure migrated linked apps can be handled properly on the next step
                egrep "\s*delete:" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app || echo "    delete: false" >> $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 
                # set removal flag
                sed -i "s/\(^\s*\)\(delete:\s*[Ff]alse\)/\1delete: true/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>> $LOG
            done
            F_DIALOG --yesno "\nDo you want to remove the choosen apps now?\n(otherwise this will just happen on next deployment run)\n\nThis will delete theses apps on $HOSTSELECTION:\n\n$RMAPPS" 15 80 
            [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

            export SHOSTFILE=$HOSTFILE
            export BTARGET="$HOSTSELECTION"
            export DEPLOYAPPSUBSET=1
            F_DEPLOYAPP auto "$RMAPPS"
        ;;
        Disable)
            F_LOG $FUNCNAME "app has been disabled"
        ;;
        Unlink)
            for app in $RMAPPS;do
                rm -vf $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>&1 >> $LOG
            done
        ;;
    esac

    F_LOG $FUNCNAME ended
}


## @fn F_SELECTOR()
## @brief Menu for selecting all or specific targets
F_SELECTOR(){
	echo "$FUNCNAME started" >> $LOG
	SELECTION=$(F_DIALOG --menu "\nChoose an option:" \
			15 76 14 \
			Choose "" \
			ALL "" \
			3>&1 1>&2 2>&3)
	echo "$SELECTION"
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_GOAPPS()
## @brief show current apps deployment
F_GOAPPS(){
	echo "$FUNCNAME started" >> $LOG
	if [ "$SELECTION" == "ALL" ];then
		F_SHOWAPPS "ALL"
	else
		if [ "$SELECTION" == "Choose" ];then
			OPTIONS=($(for i in $(find $AINVENTORY/$TARGETENV/group_vars/* -maxdepth 1 -type d |egrep -v "(templates|all)" |sed s#$AINVENTORY/$TARGETENV/group_vars/##g);do echo $i $i off;done))
			SELECTION=$(F_DIALOG --checklist "Select options:" 22 76 16 "${OPTIONS[@]}" 2>&1 >/dev/tty)
			if [ -z "$SELECTION" ];then
			F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
			else
				F_SHOWAPPS "$SELECTION"
			fi
		else
			echo ERROR no selection made 
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_HOSTFILE()
## @brief Choose / check ansible inventory file
## @param 1 optional: mode (auto|\<empty\>)
## mode auto: will set hostfile by $SHOSTFILE variable
## @details
## ask for hosts filename (will list any hosts.* files as well)
## returns either the hostfile or ABORTED if the user cancels
F_HOSTFILE(){
	F_LOG $FUNCNAME started
	STARTOVER=1
	ABORT=0
    FMODE=$1

    if [ ! -z "$FORCEDHOSTFILE" ];then
         HOSTFILE="$FORCEDHOSTFILE"
    elif [ "$FMODE" == "auto" ];then
        HOSTFILE="$SHOSTFILE"
    elif  [ "$RUNMODE" == "batch" ];then
        HOSTFILE="$SHOSTFILE"
    else
	  while [ $STARTOVER -eq 1 ];do
		unset OPTIONS SELECTION HOSTFILE SHOSTFILE
		# detect available host files
		while [ -z "$SHOSTFILE" ];do
			OPTIONS=($(for i in $(find -L $AINVENTORY/$TARGETENV -maxdepth 1 -type f -name "hosts*" |grep -v template);do echo ${i##*/} file;done))
			SHOSTFILE=$(F_DIALOG --menu "Select a hosts file:" 22 76 16 "${OPTIONS[@]}" manually "type in a path" 2>&1 >/dev/tty)
			[ $? -ne 0 ] && HOSTFILE="ABORTED" && F_ABORTMAINMENU 
		done
		if [ "$SHOSTFILE" == "manually" ];then
			SHOSTFILE=$(F_DIALOG --inputbox 'Type in your hosts filename' 20 100 $DEFHOSTFILE 2>&1 >/dev/tty)
		fi
		# construct the full host filename
		HOSTFILE="${AINVENTORY}/${TARGETENV}/${SHOSTFILE}"
		if [ ! -r "$HOSTFILE" ];then
			F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80
			STARTOVER=1
		else
			STARTOVER=0
		fi
	  done
    fi
    if [ ! -r "$HOSTFILE" ];then
	   [ "$RUNMODE" != "batch" ] && F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80 && return 3
       [ "$RUNMODE" == "batch" ] && echo "ERROR: $HOSTFILE does not exist or is not readable" && F_EXIT
	else
	    echo "HOSTFILE=\"$HOSTFILE\"" > $AEUSRHOSTFILE
	    F_LOG $FUNCNAME "written new AEUSRHOSTFILE ($AEUSRHOSTFILE):\n$(cat $AEUSRHOSTFILE)"
    fi
	F_LOG $FUNCNAME finished
}

## @fn F_TARGETS()
## @brief identify targets/hosts of a group
## @param 1 required: dialog option (checklist/radiolist)
## @param 2 optional: automatic/non interactive mode (auto selected group name|empty)
## @return list of hosts
## @exception on error or abort: abort
## @details identify targets/hosts of a group. DEPRECATED, use F_EXPANDHOSTS instead.
## 1. filter out all vars
## 2. get all sections and 1 next line
## 3. replace [ with newline
## 4. replace ] with comma, empty lines with / and remove children tag from group name
## 5. remove all newlines
## 6. replace // with /
## 7. replace / with newline
## --> steps 4-7 are required to ensure even when 2 sections are written without a space
##     between. Example:
##     [sec1]
##     [sec2]
##     host
##     As we catch always section + 1 next line on step 2 to identify empty sections the above 
##     steps ensure we will *NOT* have a result of: "sec1" has host "sec2"
## 8. get only these lines containing a comma and something behind (means section has a value)
##    this is needed as a section can be empty which shouldnt be shown if!
F_TARGETS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	unset NIGRP
	NIGRP="$2"
	
	#OPTIONS=($(for i in $(egrep -v "(:vars|:children)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort))
	OPTIONS=($(for i in $(egrep -v "(:vars)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g;s/:children//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort -u ))
	# OPTIONS EXPLANATION ABOVE

	if [ -z "$1" ];then 
		echo -e "\n\nERROR! Missing F_TARGETS arg!! Cannot continue...\n" && F_EXIT
	else
		DOPT="$1"
	fi

	if [ -z "$NIGRP" ];then
	    HOSTSELECTION=$(F_DIALOG --${DOPT} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
		HERR=$?
		F_LOG "$FUNCNAME" "HERR was $HERR"
		if [ "$HERR" != "0" ];then
			echo "ABORTED"
		else
			echo "$HOSTSELECTION"
		fi
	else
		#echo "${OPTIONS[@]} | cut -d ' ' -f 1 |grep $NIGRP"
		echo "$NIGRP"
	fi
	F_LOG "$FUNCNAME" "finished"
}


## @fn F_GVARDIR()
## @brief group_vars dir check and initiate if needed
F_GVARDIR(){
	echo "$FUNCNAME started" >> $LOG
	INIT=0
	TG=$1
	TDIR=$AINVENTORY/$TARGETENV/group_vars/$TG
	[ -z "$TG" ]&& echo "Missing arg for $FUNCNAME!! ABORTED" && F_EXIT
	if [ -d "$TDIR" ];then
		echo "$TDIR" exists >> $LOG
		if [ -f "$TDIR/deployment" ];then 
			echo already initialized >> $LOG
		else
			INIT=1
		fi
	else
		INIT=1
	fi
	if [ "$INIT" -eq 1 ];then
		echo creating $TDIR >>$LOG
		mkdir $TDIR >>/dev/null 2>&1
		ERRC=0
		while [ -z "$DEPL" ]&&[ "$ERRC" -eq 0 ];do
			DEPL=$(F_DIALOG --inputbox "Initializing of <$TDIR> required\nPlease type in where you want to deploy apps for >$TG<.\n\nJust type <apps>, <deployment-apps>,<shcluster/apps>, etc and not the full path:" 15 100 2>&1 >/dev/tty)
			ERRC=$?
		done
		if [ $ERRC -eq 0 ];then
			echo "will create deployment file with: $DEPL as target dir" >> $LOG
			# creating deployment file:
			cat >> $TDIR/deployment <<EOF_DEPL
---
#####################################################################################################################
# Configurations for Splunk deployment directory
# Keep in mind to replace "-" and "/" with an underscore "_"
#####################################################################################################################

deployment:
    dir: $DEPL
EOF_DEPL
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_DEPLSYSC()
## @brief deploy system/local configs
F_DEPLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	F_HOSTFILE
	SELECTION="$1"
	if [ "$SELECTION" == "Choose" ];then
	     unset HOSTSELECT HOSTSELECTION
	     while [ -z "$HOSTSELECT" ];do
		HOSTSELECTION=$(F_TARGETS checklist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
	         if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
                 else
                     HOSTSELECT=1
		     ABORTED=0
                 fi
	     done
	     if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
	     else
		  F_DIALOG --yesno "\nAre you sure you want to continue?\n\nThis will deploy the system/local configs to:\n\n$HOSTSELECTION" 15 80
		  if [ $? -eq 1 ];then
			ABORTED=1 
		  else
		     # TODO: optimize playbook exec to just exec on group instead of for each host
			unset HOSTSELEXPANDED
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" | grep -v EMPTY |cut -d : -f 1)
			# host 1,2,3,... of shcmember
			for hex in $HOSTSELEXPANDED;do
			     F_LOG $FUNCNAME "processing host >$hex<"
			     for hgroup in $HOSTSELECTION;do
				    F_LOG $FUNCNAME "processing $hex in >$hgroup<"
				    # for shcmember, ...
			    	#F_GVARDIR "$hgroup"

				    # update task etc stuff first
                    F_LOG $FUNCNAME "roledir: $ROLEDIR"
				    F_TPLUPDATE "${ROLEDIR}/system" "$hgroup/$hex"

				    F_LOG $FUNCNAME "Will play:\n$ABIN -i $HOSTFILE $PBDEPLSYSC -e \"target=$hgroup exp_host=$hex\""
				    $ABIN -i $HOSTFILE $PBDEPLSYSC -e "target=$hgroup exp_host=$hex"
				    ERR=$?
				    F_DIAERR "$ERR" "on \Zb\Z1<$hex>\Zn"
				    [ $ERR -ne 0 ]&& F_MSG "ERROR: ABORTED deployment!" && break 2 >>$LOG
			     done
		     done
		  fi
	     fi
	else
		F_DIALOG --msgbox "ERROR: Deploying to ALL is not supported yet" 10 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SSHORNOT()
## @brief let the user choose to either catch existing conf from another host or locally (system/local related)
F_SSHORNOT(){
	echo "$FUNCNAME started" >> $LOG
	unset ANS
	while [ -z "$ANS" ];do
		#ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 80 3 Pull "Pull existing conf from a host (copy by SCP)" on Local "Choose a local dir for importing conf" off Skip "Use the local copy (POTENTIAL DANGEROUS. Will overwrite remote changes if any)" off 2>&1 >/dev/tty)
		ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 100 5 Pull "(RECOMMENDED) Pull current active conf" on ---- "--------------------------------------" off DANGEROUS-Import "OVERWRITES REMOTE! Import configs from a LOCAL directory" off DANGEROUS-Skip "OVERWRITES REMOTE! Just use the LOCAL(!!) existing files" off 2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
	echo "$FUNCNAME finished" >> $LOG
	echo $ANS
}

## @fn F_DIMPORT()
## @brief import by ssh from an existing host (system/local related)
F_DIMPORT(){
	echo "$FUNCNAME started" >> $LOG
	SSHHOST="$1"
	SSHPATH="$2"
	LOCTMP="$3"
	[ -d $LOCTMP ]&& rm -R $LOCTMP
	mkdir $LOCTMP
	scp ${SSHHOST}:${SSHPATH}/*.conf $LOCTMP/

	# return errorcode to calling function
	echo $?

#	SIMP=$(F_DIALOG --inputbox "$TPLMSG\nNow initialize the deployment directory by copying your initial config files you want to deploy.\n\n\nWhere should I copy the initial configs from:" 15 80 2>&1 >/dev/tty)
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_DBROWSE()
## @brief file browser (system/local related)
F_DBROWSE(){
	echo "$FUNCNAME started" >> $LOG
	unset SDIR
        SDIR=$(F_DIALOG --colors --inputbox "\nSource path (full path) where to copy the initial configs from\n(on host \Zb\Z1<$1>\Zn):" 15 80 $2 2>&1 >/dev/tty)
	if [ $? -ne 0 ];then
            SDIR=999
        fi
	echo $SDIR
	echo "$FUNCNAME finished" >> $LOG
}
## @fn F_LOCSRC()
## @brief List and choose local repository files 
## @param 1 (required) Target group
## @return choosen local hosted files
F_LOCSRC(){
	F_LOG $FUNCNAME "started with $@"
	unset SDIR OPTIONS
    TG="$1"
	[ ! -d "$REPODIR" ]&& echo "Cannot determine repo dir <$REPODIR>!! ABORTED" && F_EXIT

    # ensure only apps that are not already linked will be shown
    LINKEDAPPS=$(F_LISTAPPS "$TG" | grep ansible-hosted| cut -d ":" -f 2-3)
    AVAILAPPSFP=$(for tgzf in $(find $REPODIR -type f |egrep "(tar|tgz|spl)");do echo "$tgzf";done)
    AVAILAPPNAMES=$(for tgz in $AVAILAPPSFP;do APPN=$(tar tf "$tgz" 2> /dev/null |head -n1 | cut -d '/' -f1) ; echo "${APPN}:${tgz##*/}" ;done)
    UNLINKEDAPPS=$(echo "$LINKEDAPPS" "$AVAILAPPNAMES" | tr " " "\n" | sort | uniq -u)

    F_LOG $FUNCNAME "linked: $LINKEDAPPS\n\navail: ${AVAILAPPNAMES}\n\nunlinked: $UNLINKEDAPPS"

	OPTIONS=($(for tgz in $UNLINKEDAPPS;do echo "${tgz/*:}" "${tgz/:*}" off; done | sort))
	SDIR=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 40 100 40 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        if [ $? -ne 0 ];then
            SDIR=999
        fi
        echo "$SDIR"
	F_LOG $FUNCNAME ended
}

## @fn F_EXPANDHOSTS()
## @brief create an expanded list of hostnames
## @param 1 target group name
## @param 2 optional: expandfile (file where the hosts will be written)
## @return space delimited list with the expanded list of hostnames
## @details expands a target group to a list of hostnames/ips defined in the users host file
F_EXPANDHOSTS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	unset RET TGFILE
	TGROUP=$1
	source "$AEUSRHOSTFILE"

	if [ -f "$HOSTFILE" ];then
                TGFILE="$2"
		[ -z "$TGFILE" ] && TGFILE="$AINVENTORY/$TARGETENV/${FUNCNAME}_${TGROUP}"

		# get all hosts via playbook (will expand groups in groups etc)
                [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
		F_LOG $FUNCNAME "$ABIN -i $HOSTFILE $PBGETTARGETS -e target=$TGROUP expandfile=$TGFILE"
		$ABIN -i $HOSTFILE $PBGETTARGETS -e "target=$TGROUP expandfile=$TGFILE" 2>&1 | sort >> $LOG
                F_RMVAULTPW
	
		# parse the resulted FILE and massage its content
	        if [ -r "$TGFILE" ];then
       	       # filter ansible stuff:
		      RET=$(sed "s/,//g;s/\[//g;s/]//g;s/'//g" $TGFILE)
        	else
	      	# bark no error to the calling function but an error message in log
              	F_LOG $FUNCNAME "WARNING: cant read/find $TGFILE! Empty group??"
	      	RET="EMPTY"
        	fi
	else
		F_LOG $FUNCNAME "ERROR: HOSTFILE $HOSTFILE NOT FOUND!"
	fi
	echo "$RET"
	F_LOG "$FUNCNAME" finished
}

## @fn F_VALCONF()
## @brief validate a dir if it contains conf files (system/local related)
F_VALCONF(){
	echo "$FUNCNAME started" >> $LOG
	find $1 -type f |grep -q "\.conf"
	if [ $? -ne 0 ];then
		F_DIALOG --msgbox "ERROR:\n\nThe path >$1< contains no single conf file!" 10 50
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_CLEANCONF()
## @brief delete empty conf files (system/local related)
F_CLEANCONF(){
	echo "$FUNCNAME started" >> $LOG
	CDIR=$1
	for cfile in $(find $CDIR -type f -name *.conf);do
		[ ! -s "$cfile" ]&& echo "$cfile is empty! Will remove it" >> $LOG && rm -v "$cfile" >> $LOG
	done
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_DIAERR()
## @brief dialog box providing errorcode
F_DIAERR(){
	echo "$FUNCNAME started with args: $@" >> $LOG
	ERRC="$1"
	TASK="$2"

	[ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

	if [ "$ERRC" != "0" ];then
		F_DIALOG --colors --msgbox "ERROR:\n\nTask\n\n$TASK\n\nended with errorcode >$ERRC<!" 50 150
		# TODO: option to abort completely?
	else
		F_DIALOG --colors --msgbox "SUCCESS:\n\nTask\n\n$TASK\n\nended successfully" 20 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_ERRLOG()
## @brief dialog box very similar to F_DIAERR but givin an option to display a given logfile
F_ERRLOG(){
        echo "$FUNCNAME started" >> $LOG
        ERRC="$1"
        TASK="$2"
	DLOG="$3"

        [ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

        if [ "$ERRC" != "0" ];then
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "ERROR:\n\nTask:\n\n${TASK}\n\nended with errorcode >$ERRC<!" 20 150
                # TODO: option to abort completely?
		exit_status=$?
        else
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "SUCCESS:\n\nTask:\n\n${TASK}\n\nended successfully" 20 150
		exit_status=$?
        fi
	if [ $exit_status -eq 3 ]; then
		F_DIALOG --colors --textbox "$DLOG" 50 200
	fi
        echo "$FUNCNAME finished" >> $LOG

}

## @fn F_WAITBOX()
## @brief display a wait box (very useful when something is done in the background)
F_WAITBOX(){
	# requires 1 arg (message to show)
	MSG="$1"
	F_DIALOG --infobox "\n$MSG" 5 80
}

## @fn F_SETREPODIR()
## @brief Set the local repository variable in PORS 
## @return The directory name where the local repository is defined. On error it will return nothing.
## @details Set the local repository variable in PORS
F_SETREPODIR(){  
    F_LOG $FUNCNAME started
    # local repository definition configuration file for tgz's  
    REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository

    # extract repo dir for apps
    REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")"

    # return only the repo dir when its a valid directory
    if [ -d "$REPODIR" ];then
        echo "$REPODIR"
    fi
    F_LOG $FUNCNAME "repo dir: $REPODIR"
    F_LOG $FUNCNAME ended
}

## @fn F_ENAPP()
## @brief enable an app for a host/target
F_ENAPP(){
	echo "$FUNCNAME started" >> $LOG
	unset HOSTFILE
	F_HOSTFILE
	unset HOSTSELEXPANDED ABORTED HTARGETS HOSTSELECT OPTIONS

	# local repository definition configuration file for tgz's	
	#REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository

	# extract repo dir for apps
	#REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")/apps"

    REPODIR="$(F_SETREPODIR)/apps"

        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
                 if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
                 else
                     HOSTSELECT=1
                     ABORTED=0
                 fi
        done
        if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
        else
		#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
		#F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED"

		# LOCAL or GIT
		ENSRC=$(F_DIALOG --menu "\nChoose an option:" \
                        15 76 14 \
                        gitlab "(define an available app within your gitlab server)" \
                        local "(define and push a local file on this server to a target)" \
                        3>&1 1>&2 2>&3)
		
		case $ENSRC in
			local)
			unset SELAPPS
			# TODO: select apps then choose hosts
			SELAPPS=$(F_LOCSRC "$HOSTSELECTION")
		    if [ -z "$SELAPPS" ];then
                F_DIALOG --msgbox "\n\nAll local available apps are linked to $HOSTSELECTION already ..." 15 76
            else
			    # atm we have to use group otherwise we have to switch group_vars to targetgroup/host/ as well	
                	#SELHOSTS=$(F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED")
	               	#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
			    # enable app for each target group
			    for tapp in $SELAPPS;do
				    F_WAITBOX "... linking $tapp ..."
				    app_fulldir=$(find $REPODIR -type f -name $tapp |egrep "(tar|tgz|spl)")
				    app_dir=${app_fulldir%/*}
				    app_type=$(echo "$app_dir" | egrep -o '(/other$|/splunk$)')
				    F_LOG $FUNCNAME "app_fulldir: $app_fulldir, app_dir: $app_dir, app_type: $app_type"
				    if [ "$app_type" == "/other" -o "$app_type" == "/splunk" ];then
				        app_name=$(tar tf "$app_fulldir" 2> /dev/null |head -n1 | cut -d '/' -f1)
				    else
				        app_name=${app_dir##*/}
				        app_type="/${app_name}"
				    fi
				    for tgroup in $HOSTSELECTION;do
					    F_GVARDIR $tgroup
					    echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''\":\n" >>$LOG
					    $ABIN -i $HOSTFILE $PBENAPP -e "app_type=$app_type app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''" >> $LOG 2>&1
					    [ $? -ne 0 ] && F_ERRLOG "1" "linking $app_name to $tgroup\n\n" "$LOG"
				    done
			    done
			    F_ERRLOG 0 "Linking apps finished" "$LOG"
            fi
			;;
			gitlab)
			unset SELAPPS
			# check if settings are done already:
			if [ -f $GLABSETTINGS ];then
				. $GLABSETTINGS
			else
				F_SETUP_GITLAB
			fi
			# get gitlab projects
			F_DIALOG --infobox "\nPlease standby until all gitlab projects have been parsed..." 5 80
			CSELAPPS=$(F_GITLABSRC|sort)
            echo "$CSELAPPS" |grep "returncode:0" >> $LOG
            if [ $? -eq 0 ];then
                    PREAPPS="${CSELAPPS/returncode:0}"
			        unset OPTIONS
                    # ensure only apps that are not already linked will be shown
                    RMAPPS=$(for gh in $(F_LISTAPPS "$HOSTSELECTION" | grep git-hosted | cut -d ":" -f 2);do echo "$gh\n";done)
                    LAPPS=$(for papp in $PREAPPS;do echo "${papp##*/}" ;done)
                    SELAPPS=$(echo -e "${LAPPS}\n${RMAPPS}" | sort |uniq -u)

                    F_LOG $FUNCNAME "RMS: $RMAPPS\n\nPREAPPS: ${PREAPPS}\n\nSELAPPS: $SELAPPS"
        		    OPTIONS=($(echo "CUSTOM GIT-Project off" && for gapp in $SELAPPS;do echo ${gapp##*/} "GIT-Project" off; done))
		            GLABAPP=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                if [ $? -eq 0 ];then
                    for gapp in $GLABAPP;do
				        if [ "$gapp" == "CUSTOM" ];then
					        gapp=$(F_DIALOG --inputbox '\nHINT: the project MUST exists already on the gitlab server!\nType in the gitlab project name (only the name):\n' 15 100 2>&1 >>/dev/tty)
				        fi
				        F_GITLABSRC | grep $gapp >>/dev/null
				        if [ $? -ne 0 ];then
					        F_MSG "ERROR: > $gapp < does not exists on gitlab! Please create the repository first. This app will be SKIPPED."
				        else
	                                app_full=$(echo "$SELAPPS" |tr " " "\n" |egrep "/${gapp}$")
	       	                        app_dir=${app_full%/*}
	       	                        app_namespace=${app_dir##*/}
					                F_LOG $FUNCNAME "gapp: $gapp, app_full: $app_full, app_dir: $app_dir, appnamespace: $app_namespace" 
	       	                        for tgroup in $HOSTSELECTION;do
                                        F_GVARDIR $tgroup
						                # TODO: may have an option for choosing branch?!
	                                    echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$gapp app2group=$tgroup filename='' git_url=git@${GLABHOST}:${app_namespace} git_branch=''\":\n" >>$LOG
						                F_A2BIN $HOSTFILE $PBENAPP "Enable App" "-e {'app_name':'$gapp','app2group':'$tgroup','filename':'','git_url':'git@${GLABHOST}:${app_namespace}','git_branch':'master'}"
                                        LASTERR=$?
                                        [ $LASTERR != 0 ] && F_ERRLOG "$LASTERR" "linking\n\n$gapp\n\nto $tgroup\n\n" "$LOG"
	                                done
				          fi
                       done
                       F_ERRLOG 0 "linking $GLABAPP to $tgroup\n\n" "$LOG"
                  else
                        F_DIAERR 4 "Aborted by user"
                  fi
              else
                       F_DIAERR 9 "$FUNCNAME: GITLAB API ERROR!! CHECK $LOG"
              fi
			;;
			*)
			echo NO SELECTION MADE..
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SETUP_GITLAB()
## @brief ask user and write settings to local file
F_SETUP_GITLAB(){
	echo "$FUNCNAME started" >> $LOG
	# ask for server
	# ask for personal token
	# write config if all is fine (only)
	unset GLABHOST PTOKEN ERRHOST ERRTOK
	F_DIALOG --msgbox "\n(Re-)Initializing gitlab authentication!\n" 10 80

	while [ -z "$GLABHOST" ];do
		GLABHOST=$(F_DIALOG --inputbox '\nType the FQDN/IP of your gitlab server here (no URL!):\n' 15 100 2>&1 >>/dev/tty)
		ERRHOST=$?
		[ "$ERRHOST" -ne 0 ]&& break
	done
	while [ -z "$PTOKEN" ]&&[ "$ERRHOST" -eq 0 ];do
		PTOKEN=$(F_DIALOG --inputbox '\nOpen your gitlab web GUI\n -> Open your profile settings\n -> Create a personal Access Token\n -> type that token here:\n' 25 100 2>&1 >>/dev/tty)
		ERRTOK=$?
		[ "$ERRTOK" -ne 0 ]&& break
	done
	# error out or write the config if not
	if [ "$ERRHOST" -ne 0 ]||[ "$ERRTOK" -ne 0 ];then
		F_DIAERR "host var: $ERRHOST,token var: $ERRTOK"
	else
		echo -e "GLABHOST=\"$GLABHOST\"\nPTOKEN=\"$PTOKEN\"" > $GLABSETTINGS
	fi
	echo "$FUNCNAME finished" >> $LOG
}


## @fn F_GITLABSRC()
## @brief get all available gitlab projects for the current user
## @details this does not work with other git servers (think of ssh git@git-server info for those supporting this)
F_GITLABSRC(){
	F_LOG $FUNCNAME started
	# check of required vars are set
	# build gitlab URL
	# curl with the private token 
	# parse the result with python and grep for the wanted project URLs
    # HINT: no dialogs allowed here!
	unset ERRC
	if [ ! -z "$PTOKEN" ]&&[ ! -z "$GLABHOST" ];then
		# TODO: check for curl as a req
		# TODO: check for python and python module json.tool as a req

		# I'm not that happy with this URL because it seems to be so unflexible for future changes (besides that parsing grep)
		# ... but: it works atm..
		# page=1 and per_page are required otherwise you will see the per page setting in the users settings only (default 20)
                # max=100 according to https://docs.gitlab.com/ce/api/README.html#pagination
                GLABURL="https://$GLABHOST/api/v4/projects?simple=true&per_page=100"

                curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head | egrep "HTTP/.* 200 OK" >> $LOG
                if [ $? -eq 0 ];then
                    # fetch the needed page count first, then iterate over all pages
                    PAGECNT=$(curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head | grep 'X-Total-Pages' |egrep -o '[[:digit:]]' |tr -d '\n')
                    # debugging
                    # echo "curl -k -s --header \"PRIVATE-TOKEN: $PTOKEN\" \"${GLABURL}\" --head" >> $LOG
                    PAGE=1
                    F_LOG $FUNCNAME "page count on GLABURL is: $PAGECNT starting at page: $PAGE"

                    while [ "$PAGE" -le "$PAGECNT" ];do
                        F_LOG $FUNCNAME "parsing page $PAGE ..."
                        #curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}&page=$PAGE" 2>&1 | python -mjson.tool >> $LOG
                        curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}&page=$PAGE" | python -mjson.tool | sed 's/[\",]//g' | egrep "web_url:" |sed 's/\s*web_url:\s*//g'
                        PAGE=$((PAGE + 1))
                    done
                    ERRC=$?
                else
                    curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head >> $LOG
                    F_LOG $FUNCNAME "API ERROR! Check your gitlab config!\nconnecting to $GLABURL returned an error:\n$( curl -k -s --header \"PRIVATE-TOKEN: $PTOKEN\" \"${GLABURL}\" --head)\n\nstart PORS with --advanced to re-initialize gitlab, check the access token in gitlab and ensure the gitlab API url is still correct"
                    ERRC=9
                fi
	fi
	echo "$FUNCNAME finished" >> $LOG
        echo "returncode:$ERRC"
}

## @fn F_MSG()
## @brief Just showing a simple message box with some dynamic info
F_MSG(){
	echo "$FUNCNAME started" >> $LOG
	# required arg: message
	MSG="$1"
	[ -z "$MSG" ]&& echo "FATAL: missing req arg in $FUNCNAME! ABORTED!" && F_EXIT
	F_DIALOG --msgbox "$MSG" 10 100
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_TPLUPDATE()
## @brief updating target dirs based on the template dir
## @details ensures consistent & updated tasks for all config folders
F_TPLUPDATE(){
	echo "$FUNCNAME started" >> $LOG
	# required argument: targetgroup/hostname
	unset ROLEPATH
	
	FRPATH="$1"
	ROLEPATH="$2"

	if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
		echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
	fi

	if [ -d $FRPATH/$ROLEPATH ];then
		for i in $ROLEPATH;do
			cp -av $FRPATH/template/* $FRPATH/$i/ >>$LOG
			[ $? -ne 0 ]&&echo "FATAL: Cannot copy template to $FRPATH/$i/ !" && F_EXIT
		done
	else
		F_MSG "\nERROR: cannot find specified path: $ROLEPATH!"
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_APPTPLUPDATE()
## @brief updating target dirs based on the APP template dir
## @details ensures consistent tasks for all config folders
F_APPTPLUPDATE(){
        echo "$FUNCNAME started" >> $LOG
        # required argument: targetgroup/hostname
        unset ROLEPATH FRPATH

        FRPATH="$1" # roles/apps/app.template
        ROLEPATH="$2" # roles/apps/TA-xxxxxxxxxxxxxxxxxx-dsl

        #FRPATH="roles/system"

        if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
                echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
        fi

        cp -av $FRPATH/* $ROLEPATH/ >>$LOG
        [ $? -ne 0 ] && echo "FATAL: Cannot copy template to $ROLEPATH/ !" && F_EXIT
        echo "$FUNCNAME finished" >> $LOG
}

## @fn F_PULLSYSC()
## @brief pull system/local configs for remote server (system/local related)
F_PULLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	ABORTED=0
	AUTO="$1"
	if [ -z "$AUTO" ];then
		[ -z "$HOSTFILE" ]&& F_HOSTFILE
		unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT HOSTSELECTION
       		while [ -z "$HOSTSELECT" ];do
			HOSTSELECTION=$(F_TARGETS radiolist)
			[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
       	        	if [ -z "$HOSTSELECTION" ];then
       	              		F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
       	          	else
       	              		HOSTSELECT=1
			     	ABORTED=0
       	          	fi
        	done
	fi

	if [ "$ABORTED" -ne 0 ];then
		echo "$FUNCNAME: aborted by user." >>$LOG
		echo ABORTED
	else
		if [ -z "$AUTO" ];then
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION")
			[ "$HOSTSELEXPANDED" == "ERROR" ]&& echo "FATAL: problem with expanding hosts for $HOSTSELECTION" && F_EXIT
			[ "$HOSTSELEXPANDED" == "EMPTY" ]&& F_LOG $FUNCNAME "Warning $HOSTSELECTION is empty?!"
		else
			HOSTSELEXPANDED="$AUTO"
		fi

		# set temporarly to always pull.
		# TODO: decide to make this configurable as a general user defined setting
		#ANS=$(F_SSHORNOT)
		ANS=Pull

		case "$ANS" in
			ABORTED)
			# return abort state
			echo ABORTED
			break
			;;
			DANGEROUS-Skip)
			echo SKIPPED
			;;
			DANGEROUS-Import|Pull)
	  		    for host in $(echo "$HOSTSELEXPANDED"| cut -d : -f1);do
				OWNDIR=$HOSTSELECTION/$host
				SYScDIR=${DATADIR}/system/$OWNDIR
				if [ ! -d "$SYScDIR/files" ];then
				    mkdir -p "$SYScDIR"
		    		TPLMSG="Base directory structure created!"
				else
                                    rm -vf "$SYScDIR" && mkdir -p "$SYScDIR"
				    TPLMSG="Target dir exists already. CLEANED!"
				fi
	
				# this initiates the template files but also ensures that we keep all tasks and stuff current!
				F_TPLUPDATE "${ROLEDIR}/system" $OWNDIR
	
				# do stuff based on user selection
				if [ "$ANS" == "DANGEROUS-Import" ];then
				   SELDIR=$(F_DBROWSE "$host" /TYPE-IN-LOCAL-DIR)
				   [ "$SELDIR" == "999" ] && echo "breakout!" && break
				   while [ ! -d "$SELDIR" ]&&[ "$SELDIR" -ne 999 ];do
					F_DIALOG --msgbox "ERROR:\n\nThe path you entered is not a directory!" 10 50
					SELDIR=$(F_DBROWSE $host /TYPE-IN-LOCAL-DIR)
				   done
				   [ "$SELDIR" == "999" ] && break
				else
				    if [ ! -z "$REMDIR" ];then
					REMPATH="$REMDIR"
				    else
					REMPATH="/opt/splunk/etc/system/local"
				    fi
				    # disabled user conf temporarly
				    # TODO: put this into a general setting store instead?
				    #REMDIR=$(F_DBROWSE "$host" "$REMPATH")
				    REMDIR=$REMPATH

				    echo "$FUNCNAME remdir: $REMDIR" >> $LOG
				    if [ "$REMDIR" == "999" ];then
					echo "$FUNCNAME: aborted!" >> $LOG
					ABORTED=1
				    else
					    SELDIR="/tmp/$host"
                                            [ -d "$SELDIR" ] && rm -rf $SELDIR
					    SCPERR=$(F_DIMPORT $host "$REMDIR" "$SELDIR")
					    echo "$FUNCNAME: SCPERR was $SCPERR" >> $LOG
					    [ $SCPERR -ne 0 ]&& F_MSG "ERROR: Problem while importing from >$host<"
				    fi
				fi
				if [ "$ABORTED" != "1" ];then
					F_VALCONF "$SELDIR"
					F_CLEANCONF "$SELDIR"
					# again! because clean could had cleaned all..
					F_VALCONF "$SELDIR"
					cp -v $SELDIR/*.conf $SYScDIR/system_local_configs/files/system/local/ >> $LOG
					CPERR=$?
					echo "$FUNCNAME: CPERR was $CPERR" >> $LOG
					# ask if you want to manage all files or a subset only
					#F_ASKMANAGE "$SYScDIR"
				fi
			    done
			    if [ "$SELDIR" != "999" ]&&[ "$ABORTED" != "1" ];then
				echo "$FUNCNAME: not aborted" >> $LOG
				if [ $CPERR -eq 0 ]&&[ $SCPERR -eq 0 ] ;then
					echo "$FUNCNAME: all files copied fine" >> $LOG
					#F_DIALOG --msgbox "DONE:\n\nAll files copied successfully." 15 80
				else
					echo "$FUNCNAME: ERROR: A problem occurred while copying your source files" >> $LOG
					echo "ERROR"
					#F_DIALOG --msgbox "ERROR:\n\nA problem occurred while copying your source files!" 10 50
				fi
			    else
				echo "$FUNCNAME: ABORTED" >> $LOG
				echo "ABORTED"
			    fi
			;;
			*) # this should never happen
			echo "$FUNCNAME - ERROR: No valid arg for case ($ANS)" >> $LOG
			echo "$FUNCNAME:ERROR"
			F_EXIT
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SHOWHOSTS()
## @brief shows hostnames in an expanded target group
F_SHOWHOSTS(){
	F_LOG $FUNCNAME "started"
	unset OPTIONS HTARGETS HOSTSELEXPANDED host ABORTED DIAOPT
	DIAOPT="$1"
	HOSTSELEXPANDED="$2"
	[ -z "$DIAOPT" ]&& echo "ABORTED! Missing arg for dialog in $FUNCNAME!" && return 1
	[ -z "$HOSTSELEXPANDED" ]&& echo "ABORTED! Missing arg for target group in $FUNCNAME!" && return 2

	OPTIONS=($(for host in $HOSTSELEXPANDED;do echo "$host $host off";done))

        while [ -z "$HTARGETS" ];do
	      ABORTED=0
              HTARGETS=$(F_DIALOG --${DIAOPT} "\nThe following are members of the choosen target group(s)\n<$HOSTSELECTION>\n\nMake your selection:" 30 80 50 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
	      F_LOG $FUNCNAME "HTARGETS (while): >$HTARGETS<"
        done
	F_LOG $FUNCNAME "HTARGETS (end): $HTARGETS"
	F_LOG $FUNCNAME "finished"
	# return host objects to the calling function
	[ "$ABORTED" -eq 0 ] && echo "$HTARGETS"
}

## @fn F_CHOOSEENV()
## @brief show available target environments to the user and let the user select one
F_CHOOSEENV(){
	# returns the choosen environment so call this function like:
	# ENVCHOICE="$(F_CHOOSEENV)"
	F_LOG $FUNCNAME "started"

        OPTIONS=($(for inv in $(find $AINVENTORY/* -maxdepth 0 -type d);do echo "${inv##*/} $inv off";done | sort -r))

        while [ -z "$ENVTARGET" ];do
              ABORTED=0
              ENVTARGET=$(F_DIALOG --radiolist "\nYou HAVE TO choose an environment first.\n\nThe following are the available environment(s) based on\n<$AINVENTORY>\n\nMake your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
              F_LOG $FUNCNAME "ENVTARGET (while): >$ENVTARGET<"
        done
        F_LOG $FUNCNAME "ENVTARGET (end): $ENVTARGET"
        F_LOG $FUNCNAME "finished"
        # return objects to the calling function
        [ "$ABORTED" -ne 0 ] && ENVTARGET="ABORTED"
	echo "$ENVTARGET"
}

## @fn F_EDITSYSC()
## @brief manage local conf files (system/local related)
F_EDITSYSC(){
	echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT EDITHOST host
	F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		if [ "$HOSTSELECTION" == "ABORTED" ];then
			ABORTED=1 && break
		else
                 	if [ -z "$HOSTSELECTION" ];then
                     		F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                 	else
                     		HOSTSELECT=1
                     		ABORTED=0
                 	fi
		fi
        done
        if [ "$ABORTED" -eq 1 ];then
                echo "$FUNCNAME: aborted by user." >> $LOG
        else
		HABORTED=0
		while [ $HABORTED -ne 1 ];do
			#TODO: ask if the user want to edit/open a path or manage previously pulled conf files
			# e.g. to say for the shc group do not manage authorize.conf

			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" |cut -d : -f1)
			EDITHOST="$(F_SHOWHOSTS radiolist "$HOSTSELEXPANDED")"
			[ $? -eq 1 ] && HABORTED=1 && break

			PERR=$(F_PULLSYSC $EDITHOST)
			[ "$PERR" == "ABORTED" -o "$PERR" == "ERROR" ] && HABORTED=1 && unset SELECTION &&break 
			
			echo "$FUNCNAME: Continuing after pull selection ($PERR)" >> $LOG

			SYSDIR=${DATADIR}/system_local/$HOSTSELECTION/$EDITHOST/system_local_configs/files/system/local
			unset OPTIONS
       			OPTIONS=($(for hostfile in $(find $SYSDIR -type f) ;do echo "${hostfile##*/}" "file";done|sort -f))
		        while [ -z "$FTARGET" ];do
				unset DIROPENED
        	      		FTARGET=$(F_DIALOG --colors --extra-button --ok-label "Open file" --extra-label "Open directory" --cancel-label "Finish" --menu "\nThe following are files currently active for the given host\n\n\Zb\Z1<$EDITHOST>\Zn\n\nChoose one file for editing:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
				FERR=$?
				if [ $FERR -eq 1 ];then
					ABORTED=1
					unset FTARGET && break
				else
					# if the user uses the extra button we open a dir on CLI
					if [ $FERR -eq 3 ];then
						DIROPENED=1
						unset FTARGET
						clear
						echo -e "\n\nSwitching to directory: $SYSDIR"
						echo -e "\n***********************************************************************"
						echo -e "** Go back by typing <exit> or <CTRL+D>"
						echo -e "***********************************************************************\n"
						bash --rcfile <(echo "PS1=\"$EDITHOST/system/local \$>\";cd $SYSDIR/ && ls -la")
					else
						if [ -z "$FTARGET" ];then
               	           		      F_DIALOG --msgbox "ERROR: no selection made. Choose a file." 10 30
			                                ABORTED=1
               				        else
               	             			#FTARGET=1
			                                ABORTED=0
               	 		        fi
					fi
				fi
				# open file for editing
				if [ "$ABORTED" -eq 0 ]&&[ -z "$DIROPENED" ]&&[ "$HABORTED" -ne 1 ];then
					if [ -f $SYSDIR/${FTARGET} ];then
						$EDITBIN $SYSDIR/${FTARGET}
					else
						F_DIALOG --msgbox "NO FILES THERE?! Directory seems to be empty try a pull first" 10 30
						break
					fi
					unset FTARGET
				fi	
        		done
		done
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_ABORTMAINMENU()
## @brief Force-switching to main window - DEPRECATED
## @details Use return in functions instead!
## abort the current menu and go back to MAIN dialog
F_ABORTMAINMENU(){
	F_LOG "$FUNCNAME" "started with $MAINMENU , params: $@"
	$MAINMENU
	F_LOG "$FUNCNAME" ended
}

## @fn F_SHELPER()
## @brief shelper UI
## @details Tasks using the shelper utility (incl. cluster-bundle deploy etc)
F_SHELPER(){
	F_LOG "$FUNCNAME" started
 	while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nshelper the splunk helper tool.\n\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
			16 100 16 \
			"" "" \
			"Upgrade/Install" "Will install or upgrade shelper on given machines" \
			Exec "Will execute certain shelper commands on given machines" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    return 4
		fi
		case "$SELECTION" in
			"Upgrade/Install")
			F_SHUPGRADE
			;;
			Exec)
			F_SHEXEC
			;;
		esac
	done
}

## @fn F_CALCTGROUP()
## @brief create a temporary target group with selected hosts
## @param 1 required: temporary filename
## @param 2 optional: temporary target group-name within the hosts file
## @param 3 optional: a given target group for just generating host names
## @exception when param1 missing
## @details calculate a temporary group based on user selected values
## the result is a list of hosts all added to one group which allows easy
## handling when running playbooks
F_CALCTGROUP(){
    F_LOG "$FUNCNAME" started
    unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
    TMPGRP=aetmpgrp

	[ -z $1 ] && F_LOG $FUNCNAME "ERROR: missing filename for temp hosts file" && F_EXIT

    if [ ! -z "$3" ];then
        TMPGRP="$2"
        HOSTSELECT=1
        HOSTSELECTION="$3"
    else
        [ ! -z "$2" ] && TMPGRP="$2"
    fi

	CALCGRPF=${AINVENTORY}/${TARGETENV}/$1
        > $CALCGRPF

        F_HOSTFILE
    ABORTED=0
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                [ $RUNMODE != "batch" ] && F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                                [ $RUNMODE == "batch" ] && F_EXIT 9
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded'] GRPSTATE
        #FIXME: 
        declare -A GRPSTATE

	[ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do

                # FIXME: not needed anymore? -> avoid duplicated entries
                F_LOG $FUNCNAME "array is: ${GRPSTATE[$hostlist]}"
                [ ! -z "${GRPSTATE[$hostlist]}" ] && F_LOG $FUNCNAME "$hostlist already added, skipping.." && continue
                F_LOG "$FUNCNAME" "expanding $hostlist"

                NEWENT=$(F_EXPANDHOSTS $hostlist "$CALCGRPF" | egrep -v "(EMPTY|$hostlist)")
		if [ -z "${HOSTLIST['expanded']}" ];then
		    HOSTLIST['expanded']+="$NEWENT"
		else
		    HOSTLIST['expanded']+=" $NEWENT"
		fi
                GRPSTATE["$hostlist"]=1
	done

	unset EDITHOST
        if [ $RUNMODE != "batch" ];then
	    while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
                [ $? -ne 0 ] && F_ABORTMAINMENU
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	    done
        else
            EDITHOST="${HOSTLIST['expanded']}"
        fi
        F_LOG $FUNCNAME "using $EDITHOST as calc base"

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	CALCEDHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	CALCEDHOSTST="$(echo "$CALCEDHOSTS" | sed 's/ /\\n/g')"
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will do action on: <$CALCEDHOSTS>"
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	echo '['$TMPGRP']' > ${CALCGRPF}
	for h in $CALCEDHOSTS;do echo "$h" >> $CALCGRPF && echo $h >> ${CALCGRPF}_nogrp ; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $CALCGRPF)"
}

## @fn F_NOGROUPUNIQ()
## @brief remove all group tags from a hosts file
## @details Removes all group stanza's, sort alphabetical and just write unique entries
## @param1 required: source host file name
## @param2 required: target file name
## @return 0: when everything is ok
## @return 3: when param1 is not a valid file
## @return any-other: grep errors
F_NOGROUPUNIQ(){
    F_LOG "$FUNCNAME" started
    unset SRCF TRGF

    SRCF="$1"
    TRGF="$2"

    if [ ! -f "$SRCF" ] || [ -z "$TRGF" ];then
        F_LOG $FUNCNAME "ERROR: missing SRCF or TRGF ($SRCF,$TRGF)"
        return 3
    fi

    egrep -v '^\[.*\]' $SRCF | sort -u > $TRGF
    RET=$?

    F_LOG $FUNCNAME "target file:\n$(cat $TRGF)"
    F_LOG "$FUNCNAME" "ended with $RET"
    return $RET
}

## @fn F_SPLACT()
## @brief splunk action/task/command
## @details will exec a (predefined) splunk action/task/command
## splunk_action=X (where X must be defined in common/handlers)
F_SPLACT(){ 
        F_LOG "$FUNCNAME" started
	unset SPLEXE HOSTSELECT SHEXE FLATHOSTS HOSTSELECTION SELHOSTS

        # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
        > $ITMPGRP

	while [ -z "$SPLEXE" ];do
		SPLEXE=$(F_DIALOG --radiolist "\nSelect with the space-bar an action:\n(pro tip: jump to an entry with the highlighted key shortcut)" 18 100 6 \
			stop "stop splunk>" off \
			start "start splunk>" off \
			restart "restart splunk>" off \
			restartweb "restart splunk> webservice only" off \
			custom "type any parameter you like (results in: bin/splunk <custom parapms>)" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			F_LOG "$FUNCNAME" "ABORTED due to err $ERR"
			F_ABORTMAINMENU
		fi
	done

        if [ $SPLEXE == "custom" ];then
            while [ -z "$ACUST" ];do
                [ -z "$ACUST" ] && [ ! -z "$ECUST" ] && ACUST="$ECUST"
                ACUST=$(F_DIALOG --inputbox '\n\nType your custom splunk arguments.\ne.g. "btool --debug server list"' 20 100 "" 2>&1 >/dev/tty)
                [ $? -ne 0 ] && F_ABORTMAINMENU
            done
            #ECUST=$(echo "$ACUST" | sed 's/ /SPACE/g')
            ECUST="$ACUST"
            # filter non ascii sed 's/[\d128-\d255]//g'
            unset ACUST
            SHEXE="custom"
        fi

        while [ -z "$HOSTSELECT" ];do
            HOSTSELECTION=$(F_TARGETS checklist)
            if [ "$HOSTSELECTION" == "ABORTED" ];then
                ABORTED=1 && break
                [ $? -ne 0 ] && F_ABORTMAINMENU
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && F_ABORTMAINMENU

        ACTGRP=aedosomething
        FINISHED=0

        [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
        for i in $HOSTSELECTION;do
            F_EXPANDHOSTS $i "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
        done

        # make a flat and unique list without groups
        F_NOGROUPUNIQ $ITMPGRP ${ITMPGRP}_nogrp
        NERR=$?
        [ $NERR -ne 0 ] && F_ERRLOG "$NERR" "internal error while calculating 'nogrp' file" $LOG && return 3
        FLATHOSTS=$(cat ${ITMPGRP}_nogrp |tr '\n' ' ')

        # ask user which hosts he/she wants
        while [ -z "$SELHOSTS" ];do
            SELHOSTS=$(F_SHOWHOSTS checklist "${FLATHOSTS}")
            WERR=$?
            [ $WERR -eq 0 ] && [ ! -z "$SELHOSTS" ] && continue
            [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
        done

        unset PBH
        for i in ${SELHOSTS/:*};do 
            if [ -z "$PBH" ];then
                PBH="$i"
            else
                PBH="$PBH:$i"
            fi  
        done
        PBARGS="--limit $PBH"
 
        EVARFILE=/tmp/pors_${FUNCNAME}
        echo -e "splunk_action: \"$SPLEXE\"\nsplunk_cmdparams: \"$ECUST\"\n" > $EVARFILE

        F_A2BIN "$ITMPGRP" "$PBSPLACT" "running splunk $SPLEXE on $SELHOSTS ..." "$PBARGS" "$EVARFILE"
        LASTERR=$?
        F_ERRLOG "$LASTERR" "splunk <${SPLEXE}> ${ECUST} for:\n\n$SELHOSTS" "$LOG"
	F_LOG $FUNCNAME "ended with $LASTERR"
        return $LASTERR
}

## @fn F_SHEXEC()
## @brief splunkhelper actions
## @details execute splunk helper commands
F_SHEXEC(){ 
    F_LOG "$FUNCNAME" started
    unset ANS
    unset TMPGRP #TMPGRP=aetmpgrp
    unset ADDIGRP
    unset SCNDGRP

    if [ $RUNMODE != "batch" ];then
	while [ -z "$ANS" ];do
		ANS=$(F_DIALOG --radiolist "\nSelect with the space-bar your shelper action:\n(pro tip: jump to an entry with the highlighted key shortcut)" 15 100 6 \
			reload-all "shelperreload all - like a 'debug refresh'" on \
			DS-reload "[WIP - do not use yet] reloads the serverclass on a DS (deploymentserver)" off \
			SHC-apply-cb "apply cluster-bundle on a DEP (deployer)" off \
			MN-apply-cb "apply cluster-bundle on a MN (masternode)" off \
			custom-reload "define your own reload command" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
    else
        # use the batch parameter to set the action type
        ANS=$BATCHACT
        F_LOG "$FUNCNAME" "Using cli param $ANS for action type"
    fi



	case $ANS in 
		custom-reload)
			unset SHCUST
			while [ -z "$SHCUST" ];do
                	  SHCUST=$(F_DIALOG --inputbox '\n\nType your custom reload arguments (space separated).\ne.g. "apps panels transforms searches"' 20 100 "" 2>&1 >/dev/tty)
                	  [ $? -ne 0 ] && F_ABORTMAINMENU
        		done
			SHEXE="reload_custom"
			#SHCUST=$(echo $SHCUSTRAW | sed 's/ /SPACE/g')
		;;
		reload-all) SHEXE="reload_all" ;;
                DS-reload) SHEXE="reload_deploy_server" ;TMPGRP=deploymentserver ;;
                MN-apply-cb) SHEXE="apply_cluster_bundle" ; TMPGRP=masternode ;;
                SHC-apply-cb) SHEXE="apply_shcluster_bundle"; TMPGRP=deployer ; SCNDGRP=shcmember ;;
		*)	# TODO: do not exit but go to MAIN
			F_LOG $FUNCNAME "no answer given! aborted!"
			return 6
		;;
	esac
    [ $RUNMODE == "batch" ] && TMPGRP=$BTARGET
    F_LOG $FUNCNAME "Starting calc with $TMPGRP"

    # calc temp hosts file
    F_CALCTGROUP shelperhosts $TMPGRP $TMPGRP

    # some targets require other groups as a dependency in the tmp host file we generated in F_CALCTGROUP
    if [ ! -z "$SCNDGRP" ];then
        HOSTSELECTION=$(F_TARGETS checklist $SCNDGRP)
        unset HOSTLIST['expanded']
        [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all group members are generated" 5 80
        for hostlist in $HOSTSELECTION;do
            if [ -z "${HOSTLIST['expanded']}" ];then
                HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
            else
                HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
            fi
        done
        echo -e '\n['$SCNDGRP']' >> ${AINVENTORY}/${TARGETENV}/shelperhosts
        echo "${HOSTLIST['expanded']}" >> ${AINVENTORY}/${TARGETENV}/shelperhosts
    fi

    OLDPP="$PYTHONPATH"
    F_LOG $FUNCNAME "python path before: $OLDPP"
    export PYTHONPATH=${A2PATH}/lib
	export PYTHONUNBUFFERED=1
    F_LOG $FUNCNAME "python path after: $PYTHONPATH"

    #[ ! -z "$SPLPW" ] && SHEXE="$SHEXE with auth"
    F_LOG $FUNCNAME "will use >$SHEXE<"

    # TODO: this is obsolete.. we should move on and stop support no-vault installs?!
    if [ "$ENABLEVAULT" != "yes" ];then
	CREDS=$(F_GETAPICREDS)
	SPLUSR="${CREDS/:*}"
	SPLPW="${CREDS/*:}"
        ARGS="{'splunk_user':'$SPLUSR','splunk_password':'$SPLPW','shelper_action':'$SHEXE','shelper_custom':'$SHCUST'}"
        $A2BIN -i "${AINVENTORY}/${TARGETENV}/shelperhosts" "$PBSHRELOAD" --limit $TMPGRP -e "$ARGS" 2>&1 \
		| tee -a $LOG \
		| sed -u -r 's/(.*DEPRECATION.*)//Ig' \
		| F_DIALOG --scrollbar --colors --progressbox "\\Za\\Z1shelper running with $SHEXE $SHCUST on $UPGRADEHOSTS ...\\Z\\n" 1000 1000
        F_ERRLOG "${PIPESTATUS[0]}" "$SHEXE $SHCUST for:\n\n$UPGRADEHOSTST" "$LOG"
        export PYTHONPATH="$OLDPP"  
        F_LOG $FUNCNAME "previous python path restored: $PYTHONPATH"
    else
        ARGS="{'shelper_action':'$SHEXE','shelper_custom':'$SHCUST'}"
        F_LOG $FUNCNAME "Will exec:\n$A2BIN -i ${AINVENTORY}/${TARGETENV}/shelperhosts $PBSHRELOAD --limit $TMPGRP -e $ARGS" 
        F_A2BIN "${AINVENTORY}/${TARGETENV}/shelperhosts" "$PBSHRELOAD" "executing ${SHEXE}${SHCUST} ..." "--limit $TMPGRP -e $ARGS"
        AERR=$?
        [ $RUNMODE != "batch" ] && F_ERRLOG "$AERR" "$SHEXE $SHCUST for:\n\n$UPGRADEHOSTST" "$LOG"
        [ $RUNMODE == "batch" ] && F_LOG "$AERR" "$SHEXE $SHCUST for:\n\n$UPGRADEHOSTST"
    fi

    [ $RUNMODE != "batch" ] && F_MENUMAIN
}

## @fn F_SHUPGRADE()
## @brief install/upgrade/use shelper
F_SHUPGRADE(){
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	PLPW=""
	SPLPWR=fail

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will upgrade/install shelper on: <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "Will upgrade/install shelper on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	UTMPGRP=${AINVENTORY}/${TARGETENV}/shelperhosts
	echo '[tmpshmaint]' > $UTMPGRP
	for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $UTMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBSHINSTALL '--limit tmpshmaint" | tee -a $LOG

	# do it
	F_A2BIN "$UTMPGRP" "$PBSHINSTALL" "\Za\Z1UPGRADING/INSTALLING ...\Z\n" "--limit tmpshmaint" 
        F_ERRLOG "${PIPESTATUS[0]}" "shelper upgrade/install for:\n\n$UPGRADEHOSTST" "$LOG"
}

## @fn F_GETAPICREDS()
## @brief ask for splunk_user and splunk_password vars - DEPRECATED - use VAULT instead
F_GETAPICREDS(){
	PLPW=""
	SPLPWR=fail

	while [ "$SPLPW" != "$SPLPWR" ];do
		[ -z "$PREUSR" ] && PREUSR=$DEFSPLAPIADMIN

		SPLUSR=$(F_DIALOG --inputbox '\n\nADMIN username for splunk API\n(only required for Indexer peer nodes - leave empty otherwise)' 20 100 $PREUSR 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		PREUSR=$SPLUSR
		SPLPW=$(F_DIALOG --passwordbox '\n\nADMIN password for splunk API\n(supports only these special chars for sure: -,_,%,@)\nYOU WILL SEE NOTHING WHILE TYPING!' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		SPLPWR=$(F_DIALOG --passwordbox '\n\nTo verify the ADMIN password for splunk API write it again' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		[ "$SPLPW" != "$SPLPWR" ] && F_DIAERR "3" "ERROR: Passwords doesn't match!"
	done

	[ -z "$SPLPW" ]&& F_LOG $FUNCNAME "No password set!"
	echo "$SPLUSR:$SPLPW"
}

## @fn F_LISTSPLREPO()
## @brief Lists splunk versions in the local repo
## @return a list of splunk packages (filenames) ordered by version top-level down
## @details Lists available splunk versions in the local repository
F_LISTSPLREPO() { 
    F_LOG $FUNCNAME started
    REPODIR="$(F_SETREPODIR)"
    find ${REPODIR}/packages -maxdepth 1 -type f -name splunk*rpm -or -name splunk*deb -or -name splunk*tgz | tac | sed 's#.*/##g'
    F_LOG $FUNCNAME ended
}

## @fn F_DLSPLUNK()
## @brief Downloads a specific splunk release
## @return success/error
## @details Takes an URL parses the relevant parts out of it and downloads splunk to the local repo
F_DLSPLUNK() { 
    F_LOG $FUNCNAME started
    while [ -z "$VERINFO" ];do
        VERINFO=$(F_DIALOG --colors --inputbox 'This will download splunk based on just the version number & the hash value.\nGuide to get version and hash:\n\n1) open https://www.splunk.com/page/previous_releases#x86_64linux\n   (select the URL and use your terminal copy-hotkey)\n2) find the wanted version but do not click on it\n3) identify the version and hash from the package name\n\nExample:\nsplunk-\Zb7.0.1-2b5b15c4ee89\ZB-Linux-x86_64.tgz\n\nResult: \n7.0.1 = version, 2b5b15c4ee89 = hash\n\nType or paste in the version & hash ONLY.\nThe format must be exactly like this: 7.0.1-2b5b15c4ee89 (X.x.x-hash):\n' 30 100 2>&1 >>/dev/tty || echo 1)
        F_LOG $FUNCNAME "input was: $VERINFO"
        [ "$VERINFO" == "1" ] && unset VERINFO && return 3
        
        echo "$VERINFO" | egrep -q "[0-9]*\.[0-9]*\.[0-9]*-\w*"
        if [ $? -eq 0 ];then
            NVER=$(echo "$VERINFO" | cut -d "-" -f 1 | tr -d " ")
            NHASH=$(echo "$VERINFO" | cut -d "-" -f 2 | tr -d " ")
            if [ -z "$NVER" ];then
                unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk version! Try again" "$LOG"
            else
                echo "$NVER" | egrep -q "^[[:digit:]]"
                [ $? -ne 0 ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Version does not start with a number! Try again" "$LOG"
            fi  
            [ -z "$NHASH" ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk hash! Try again" "$LOG"
        else
            F_ERRLOG "3" "$FUNCNAME: You typed: $VERINFO which is not in the correct format!" "$LOG"
            unset VERINFO
        fi
    done
    # auto-stage the given version 
    F_STAGESPL "${NVER}:${NHASH}"
   
    F_LOG $FUNCNAME "Parsed version: $NVER, parsed hash: $NHASH"
    
    # download the auto-staged version
    [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
    F_A2BIN $HOSTFILE $PBDLSPL "Downloading splunk <$NVER>..."
    ERR=$?
    F_RMVAULTPW
    F_DIAERR $ERR "Downloading splunk version: $NVER"
    [ $ERR -eq 0 ] && F_DIALOG --infobox "\nSplunk $NVER has been staged automatically." 5 80
    
    F_LOG $FUNCNAME ended
}

## @fn F_GETSTAGEDSPL()
## @brief Get the current staged splunk version
## @return version string of the current staged splunk package
## @details Parses the local global var to identify the current staged splunk version
F_GETSTAGEDSPL(){ 
    F_LOG $FUNCNAME started
    # extract repo dir for apps
    STAGEDVER="$(grep ^globversion "$AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF" |cut -d ":" -f 2 | grep -Po '\d+\.\d+\.\d+')"
 
    if [ ! -z "$STAGEDVER" ];then
        echo "$STAGEDVER"
    fi
    F_LOG $FUNCNAME "current version string: $STAGEDVER"
    F_LOG $FUNCNAME ended
}

## @fn F_STAGESPL()
## @brief Stage a specific splunk version from the local repository
## @param 1 OPTIONAL: splunk version:hash -> will auto-stage the given version + hash
## @return success/error
## @details Parses the local repository for available splunk versions, let the user choose and stage that version for the PORS upgrade function
F_STAGESPL(){ 
    F_LOG $FUNCNAME "started with $@"
    unset FVER VER VERHASH SELECTION AUTOVER
    AUTOVER="$1"
    STAGEDSPLVER=$(F_GETSTAGEDSPL)
    
    if [ -z "$AUTOVER" ];then
        # get the local avail versions
        OPTIONS=($(for i in $(F_LISTSPLREPO | grep -P -o "splunk-(\d+\.\d+\.\d+)-(\w+)");do VER=$(echo "${i}" | cut -d "-" -f 2); VHASH=$(echo "${i}"| cut -d "-" -f 3); echo "$VER" "$VHASH" off;done))

	    F_LOG $FUNCNAME "splunk packages found in local repo:\n$(F_LISTSPLREPO)"

        SELECTION=$(F_DIALOG --colors --ok-label "Stage" --radiolist "\nThe following shows your local repository for splunk Enterprise packages\n\nCurrently active/staged splunk version:\n\n \Zb\Zu${STAGEDSPLVER}\ZB\ZU\n\nTo stage another version simply select (space bar) and choose select.\n\n" \
                40 80 40 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)

        [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

        FVER=$(echo "${OPTIONS[@]}" | egrep -o "$SELECTION.*" | cut -d " " -f 1-2)
        VER=$(echo "${FVER}" | cut -d " " -f 1)
        VERHASH=$(echo "${FVER}" | cut -d " " -f 2)
    else
        SELECTION="$AUTOVER"
        VER="${SELECTION/:*}"
        VERHASH="${SELECTION/*:}"
    fi
    F_LOG $FUNCNAME "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF"
    sed -i "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g" $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF
    [ -z "$AUTOVER" ] && F_DIAERR $? "Staging splunk (VER: $VER, VERHASH: $VERHASH)"

    F_LOG $FUNCNAME "staged version: $SELECTION (FVER: $FVER, VER: $VER, VERHASH: $VERHASH)"
    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADESPLC()
## @brief WIP - upgrading splunk cluster env
## @details WIP - upgrading splunk cluster env
F_UPGRADESPLC(){ 
    F_LOG $FUNCNAME started
	# ask:
	#   test? -> Major release? then: no splunk offline!
	#
	#   Upgrade all tiers at once?
	# 	Stop the master.
	#	Stop all the peers and search heads. 
	#	When bringing down the peers, use the splunk stop command, not splunk offline.
	#	Upgrade the master node, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Do not upgrade the peers yet.
	#	Start the master
	#	Run splunk enable maintenance-mode on the master. 
	#	To confirm that the master is in maintenance mode, run splunk show maintenance-mode
	#	Upgrade the peer nodes and search heads, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Start the peer nodes and search heads
	#	Run splunk disable maintenance-mode on the master. To confirm that the master is not in maintenance mode, run splunk show maintenance-mode.

	#   Upgrade each tier separately
	#	Upgrade the master node.
	#	Upgrade the search head tier:
	#		Stop all cluster members.
	#		Upgrade all members.
	#		Stop the deployer.
	#		Upgrade the deployer.
	#		Start the deployer.
	#		Start the members.
	#		Wait one to two minutes for captain election to complete. The cluster will then begin functioning.
	#	Upgrade the peer node tier
	#		Run splunk enable maintenance-mode on the master. 
	#		To confirm that the master is in maintenance mode, run splunk show maintenance-mode on the master. 
	#		Stop all the peer nodes. 
	#		When bringing down the peers, use the splunk stop command, not splunk offline.
	#		Upgrade the peer nodes, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual.
	#		Start the peer nodes, if they are not already running.
	#		Run splunk disable maintenance-mode on the master.  

	# 1) MN
	# 2) SH cluster
	# 3) DEP
	# 4) Maintenance mode on
	# 5) IX cluster
	# 6) Maintenance mode off
	# 7) DS, DMC, HF, AI, LM, dev SH's
	# 8) specials: old AI (xxxxxxxxxxxxxxxxxx05), CDC SH
	# 

	F_LOG $FUNCNAME ended
}

## @fn F_SELHOST()
## @brief Show and choose host(s)
## @param 1 specify a target group directly (non interactive - will just output ALL(!) the host(s) of a group)
## @details Parsing the inventory, offering all groups found, parsing groups including childs, remove dups, offer host list and let the user choose
## @exception on abort: F_ABORTMAINMENU, on failure: error dialog
F_SELHOST(){
        F_LOG $FUNCNAME started
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup TGRP PREFILTER
	TGRP="$1"
        PREFILTER="$2"

        F_LOG $FUNCNAME "LISTTYPE=$LISTTYPE"
        [ -z "$LISTTYPE" ] && LISTTYPE=checklist && F_LOG $FUNCNAME "Using default list type: $LISTTYPE"

	if [ -z "$TGRP" ]||[ ! -z $PREFILTER ];then
	  source $AEUSRHOSTFILE
          [ -f "$HOSTFILE" ] || F_HOSTFILE
          while [ -z "$HOSTSELECT" ];do
                if [ -z $PREFILTER ];then
                    HOSTSELECTION=$(F_TARGETS $LISTTYPE)
                else
                    HOSTSELECTION="$(F_TARGETS $LISTTYPE) | grep $PREFILTER"
                fi
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
				F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
          done
	else
		HOSTSELECTION="$TGRP"
		ABORTED=0
	fi

	if [ $ABORTED -eq 1 ];then
        F_LOG $FUNCNAME "aborted by user"
		echo ABORTED
	else
		# ask for specific hosts or target group?
		unset HOSTLIST['expanded']
		if [ -z "$TGRP" ];then
			  F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80 2>&1 > /dev/tty
		fi
			  for hostlist in $HOSTSELECTION;do
				if [ -z "${HOSTLIST['expanded']}" ];then
					HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				else
					HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				fi
			  done

		unset EDITHOST
		# select hosts interactive or not depending on how we get called
		if [ -z "$TGRP" ];then
			  while [ -z "$EDITHOST" ];do
			        EDITHOST=$(F_SHOWHOSTS $LISTTYPE "${HOSTLIST['expanded']}")
				if [ -z "$EDITHOST" ];then
					F_LOG $FUNCNAME "No selection made / EDITHOST empty!"
					F_DIALOG --yesno "No selection made! Retry?" 10 40
					[ $? -ne 0 ] && F_ABORTMAINMENU
				fi
			  done
		else
			EDITHOST=$(echo "${HOSTLIST['expanded']}")
		fi
			  # make host list unique to avoid duplicated task runs when a host is in multiple groups
			  # number each entry,sort by name and remove dups, sort by num
			  echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' '
	  fi
}

## @fn F_INSTALLSPL()
## @brief Install splunk on ansible prepared servers
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
F_INSTALLSPL(){
        F_LOG $FUNCNAME started
	# this installs pure splunk (i.e. without any configuration)
	
        SHOSTS="$(F_SELHOST)"
        [ "$SHOSTS" == ABORTED ] && return 4
        SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z "$SHOSTST" ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi
	
	F_LOG "$FUNCNAME" "Will install splunk on <$SHOSTS>"
	F_DIALOG --scrollbar --yesno "Will install Splunk on these hosts:\n\n$SHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

        echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
	echo '[tmpgrp]' >> $ITMPGRP
	for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
	if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

	F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

	# doit
	F_A2BIN "$ITMPGRP" "$PBINSTALL" "\Za\Z1INSTALLING ...\Z\n" "--limit tmpgrp " 
        F_ERRLOG "${PIPESTATUS[0]}" "Installing splunk on:\n\n$SHOSTST" "$LOG"

	# cleanup
	[ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

    F_LOG $FUNCNAME ended
}

## @fn F_INSTALLLOGSTREAM()
## @brief Install cribl logstream on ansible prepared servers
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
F_INSTALLLOGSTREAM(){
        F_LOG $FUNCNAME started
        unset HOSTSELECT
        ABORTED=0
        F_DIALOG --infobox "\nCollecting hostnames ..." 5 80

        SHOSTS="$(F_EXPANDHOSTS logstream_worker)"
        [ "$SHOSTS" == ABORTED ] && return 4

        while [ -z "$HOSTSELECT" ];do
	    OPTIONS=($(for i in $(echo "${SHOSTS}" );do echo ${i/:*} $i off; done | sort -u ))
            HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && ABORTED=1
            F_LOG $FUNCNAME "HOSTSELECTION=$HOSTSELECTION, ABORTED=$ABORTED"
            if [ "$HOSTSELECTION" == "ABORTED" ]||[ $ABORTED -eq 1 ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && F_ABORTMAINMENU

        SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ] || [ -z "$HOSTSELECTION" ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) or HOSTSELECTION ($HOSTSELECTION) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi


        F_LOG "$FUNCNAME" "Will install cribl logstream on <$HOSTSELECTION>"
        F_DIALOG --scrollbar --yesno "Will install cribl logstream on these hosts:\n\n$SHOSTST\n\nAre you sure?" 30 100
        [ $? -ne 0 ] && F_ABORTMAINMENU

        # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

        echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
        echo '[logstream_worker]' >> $ITMPGRP
        for h in $HOSTSELECTION;do echo "$h" >> $ITMPGRP; done
        if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

        CRIBLMN=$(F_SELHOST logstream_mn)
        echo -e '\n[logstream_mn]' >> $ITMPGRP
        echo "$CRIBLMN" >> $ITMPGRP

        F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

        F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALLLOGSTREAM --limit logstream_worker"

        # doit
        F_A2BIN "$ITMPGRP" "$PBINSTALLLOGSTREAM" "\Za\Z1INSTALLING ...\Z\n" "--limit logstream_worker"
        F_ERRLOG "${PIPESTATUS[0]}" "Installing cribl logstream on:\n\n$SHOSTST" "$LOG"

        # add service account
        for h in $HOSTSELECTION;do
            F_ADDSYSUSER "$h" "$OS_SERVICE_USER" cribl
        done
        F_ERRLOG "$?" "Installing cribl logstream on:\n\n$SHOSTST" "$LOG"

        # cleanup
        [ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDSYSUSER()
## @brief Creates a linux user account and add it to a group
## @param1 (required) the remote hostname where the user should be created
## @param2 (required) the username to be added
## @param3 (required) the linux group name 
## @return success|fail
## @details The user created will get a random strong password and so has to
## user pubkey authentication instead.
F_ADDSYSUSER(){
    F_LOG $FUNCNAME started
    _HOST=$1
    _USER=$2
    _GRP=$3
    _PASS=$(pwgen -1 40)

    if [ -z $_HOST ]||[ -z $_USER ]||[ -z "$_GRP" ]||[ -z "$_PASS" ];then
        F_LOG $FUNCNAME "HOST, USER, GRP or PASS missing: $_HOST, $_USER, $_GRP, $_PASS"
        F_ABORTMAINMENU
    fi

    F_A2BIN $HOSTFILE $PBCREATEUSER "\Za\Z1Adding Linux user ...\Z\n" "--limit $_HOST -e {'target':'$_HOST','user_name':'$_USER','user_pass':'$_PASS','appadm':'$_GRP'}"

    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADEMENU()
## @brief A submenu for upgrade tasks
## @return a submenu action
## @details Shows several upgrade tasks in an own submenu
F_UPGRADEMENU(){ 
    F_LOG $FUNCNAME started
    unset SELECTION
    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuUpgrade Tasks\ZB\ZU'\
                        "" "" \
                        Download "Downloads a specific splunk version" \
                        Stage "Shows and sets a specific version for the upgrade tasks" \
                        Upgrade-Splunk "upgrade without a specific order (if multiple targets: in parallel)" \
                        Guided-Upgrade "of splunk instance(s) in a specific order (sequentially)" \
                        Upgrade-System "the operating system of a splunk server" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected upgrade task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
    else
        case "$SELECTION" in
            Download)
                F_DLSPLUNK
                F_UPGRADEMENU
            ;;
            Stage)
                F_STAGESPL
                F_UPGRADEMENU
            ;;
            Upgrade-Splunk)
                F_UPGRADESPL
                F_UPGRADEMENU
            ;;
            Guided-Upgrade)
                F_GUIDEDUPGRADE
                F_UPGRADEMENU
            ;;
            Upgrade-System)
                F_SYSUPGRADE
                F_UPGRADEMENU
            ;;
            *)
                F_ABORTMAINMENU
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADESPL()
## @brief Upgrade splunk
F_UPGRADESPL(){
    F_LOG $FUNCNAME "started with: $@"
	# Prepare new version?
	# -> Setup the configs
	# -> Show the current staged version
	# Ask for hostfile
	# Ask for hosts OR/AND target groups?
	# Use upgrade playbook

    unset AUTOMODE PARENTPID

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP
    
    export PARENTPID=$BASHPID

    AUTOMODE="$1"
    if [ -z "$AUTOMODE" ];then
    	UPGRADEHOSTS="$(F_SELHOST)"
        [ "$UPGRADEHOSTS" == ABORTED ] && return 4
	    #CREDS=$(F_GETAPICREDS)
	    #SPLUSR="${CREDS/:*}"
	    #SPLPW="${CREDS/*:}"
    else
        UPGRADEHOSTS="$AUTOMODE"
    fi

	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

	if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
		F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
		F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
	else
		F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
	fi

	F_LOG "$FUNCNAME" "Will upgrade <$UPGRADEHOSTS>"

    if [ -z "$AUTOMODE" ];then
            F_DIALOG --scrollbar --yesno "Will upgrade Splunk on these hosts IN PARALLEL(!!):\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	    if [ $? -ne 0 ];then
                F_ABORTMAINMENU
            else
	        # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	        UTMPGRP=${AINVENTORY}/${TARGETENV}/upgrhosts

                # target environment must be set always
                echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" > $UTMPGRP

	        echo '[tmpupgrade]' >> $UTMPGRP
	        for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	        if [ $? -ne 0 ];then
                    F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
                    F_ABORTMAINMENU
                else
    	            F_LOG "$FUNCNAME" "Temporary upgrade group: $(cat $UTMPGRP)"
	            # upgrade
 	            F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBUPGRADE --limit tmpupgrade" | tee -a $LOG
	            F_A2BIN "$UTMPGRP" "$PBUPGRADE" "\Za\Z1UPGRADING ...\Z\n" "--limit tmpupgrade" 
                    F_ERRLOG "${PIPESTATUS[0]}" "Upgrade for:\n\n$UPGRADEHOSTST" "$LOG"
                fi
            fi
    else
            F_LOG $FUNCNAME "F_A2BIN $HOSTFILE $PBUPGRADE '--limit $AUTOMODE -e \"splunk_user=$SPLUSR splunk_password=$SPLPW\"" | tee -a $LOG
            F_A2BIN "$HOSTFILE" "$PBUPGRADE" "\Za\Z1UPGRADING ...\Z\n" "--limit $AUTOMODE -e {'splunk_user':'$SPLUSR','splunk_password':'$SPLPW'}"
            UPERR=${PIPESTATUS[0]}
            F_LOG $FUNCNAME "Upgrade for:\n\n$UPGRADEHOSTST ended with: $UPERR"
            return $UPERR
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_GUIDEDUPGRADE()
## @brief Guided upgrade of several splunk servers and clusters
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
## @details Prepare your very own upgrade order 
F_GUIDEDUPGRADE(){
    F_LOG $FUNCNAME started

    unset HOSTSELECT UHOSTS
    ABORTED=0
    UHOSTS="$1"

    if [ -z "$UHOSTS" ];then
        F_DIALOG --infobox "\nCollecting hostnames ..." 5 80

        SHOSTS="$(F_EXPANDHOSTS all |grep -v localhost)"
        [ "$SHOSTS" == ABORTED ] && return 4

        STAGEDSPLVER=$(F_GETSTAGEDSPL)

        while [ -z "$HOSTSELECT" ];do
	    OPTIONS=($(for i in $(echo "${SHOSTS}" );do echo ${i/:*} "(space_to_select)" off; done | sort -u ))
            HOSTSELECTION=$(F_DIALOG --colors --checklist "\nPlease use the space-bar to make your selection to install splunk \Zb\Zuv${STAGEDSPLVER}\ZB\ZU\n" 50 100 100 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && ABORTED=1
            F_LOG $FUNCNAME "HOSTSELECTION=$HOSTSELECTION, ABORTED=$ABORTED"
            if [ "$HOSTSELECTION" == "ABORTED" ]||[ $ABORTED -eq 1 ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && F_ABORTMAINMENU
    else
        HOSTSELECTION="$UHOSTS"
        ABORTED=0
    fi
    
    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ] || [ -z "$HOSTSELECTION" ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) or HOSTSELECTION ($HOSTSELECTION) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG $FUNCNAME "hostsel: $HOSTSELECTION"

    FORMARGS='50 100 35 '      # height, width, form height

    FLINE=1
    for tg in $HOSTSELECTION;do
        FORMARGS+=' '"$tg"' '$FLINE' 1 1 '$FLINE' 40 4 3'
        FLINE=$((FLINE + 1))
    done

    F_LOG $FUNCNAME "FORMARGS: $FORMARGS"

    #UPGRADEHOSTS="$(F_SELHOST)"
    #UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

    #if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
    #            F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
    #            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    #else
    #            F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
    #fi
    #F_LOG $FUNCNAME "UPGRADEHOSTS: $UPGRADEHOSTS\nUPGRADEHOSTSST: $UPGRADEHOSTST"

    UPGORDER=$(F_DIALOG --colors --form "\nPuzzle your custom order for upgrading splunk to \Zb\Zuv${STAGEDSPLVER}\ZB\ZU\n\nHowto:\nweight each target group with a number from 001-999 (or 1-9, 01-99, 001-999).\nThe upgrade will be done from LOW to HIGH based on these numbers.\n\n\nNote: upgrades do NOT happen in parallel but \Zbsequentially\ZB.\n\nWARNING:\n\ZbTHERE IS NO WAIT BETWEEN EACH HOST SO JUST SELECT WHAT YOU WANT TO UPGRADE IN ONE RUN!!!\ZB\n" \
               $FORMARGS \
               3>&1 1>&2 2>&3 )
    if [ $? -ne 0 ];then
        F_LOG $FUNCNAME "aborted on user request"
        F_ABORTMAINMENU
    fi
    SORTED=$(for num in $UPGORDER;do \
                F_LOG $FUNCNAME "prehostsel: $HOSTSELECTION"; \
                CURSEL=$(echo "$HOSTSELECTION" |cut -d ' ' -f1); \
                echo "${num}:${CURSEL}"; \
                HOSTSELECTION=$(echo "$HOSTSELECTION" | sed "s/$CURSEL //g" ); \
                F_LOG $FUNCNAME "posthostsel: $HOSTSELECTION CURSEL $CURSEL"; \
             done | sort -u |sort -n)
    
    F_LOG $FUNCNAME "UPGORDER=$UPGORDER\nSORTED: $SORTED"
    SORTO=$(echo -e "$SORTED" | sed 's/\n/,/g')
    F_LOG $FUNCNAME "$SORTO"

    F_DIALOG --colors --scrollbar --yesno "Will upgrade Splunk to \Zb\Zuv${STAGEDSPLVER}\ZB\ZU in this order:\n\n${SORTO}\n\nAre you sure?" 30 100
    if [ $? -ne 0 ];then
        F_ABORTMAINMENU
    else	
        for utg in $SORTED;do
            F_UPGRADESPL "${utg/*:/}"
            UPERR=$?
            [ $UPERR -ne 0 ] && break
        done
        F_ERRLOG "$UPERR" "Upgrade to splunk v${STAGEDSPLVER} for:\n\n$SORTED" "$LOG"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYMENU()
## @brief A submenu for app deployment tasks
## @return a submenu action
## @details Shows several deployment tasks in an own submenu
F_DEPLOYMENU(){ 
    F_LOG $FUNCNAME started
    unset SELECTION DEPLOYAPPSUBSET
    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuApp-Deployment Tasks\ZB\ZU'\
                        "" "" \
                        Choose "(Re-)Deploy only specific App(s) on a target" \
                        ALL-Apps "Deploy all linked Apps of a target" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
    else
        case "$SELECTION" in
            Choose)
                export DEPLOYAPPSUBSET=1
                F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            ALL-Apps)
                export DEPLOYAPPSUBSET=0
                F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            *)
                F_ABORTMAINMENU
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}


## @fn F_DEPLOYAPP()
## @brief Deploy Apps to (a) specified target(s)
## @details Deploy Apps to (a) specified target(s)
## 1. Ask for hostfile
## 2. update all apps based on template
## 3. re-create deploy playbook to reflect manual changes like deleting an app
## 4. Ask for target group(s) to deploy
## 5. Deploy
F_DEPLOYAPP(){ 
        F_LOG $FUNCNAME "started with: $1 $2"
	# Ask for hostfile
	# update all apps based on template
	# re-create deploy playbook to reflect manual changes like deleting an app
	# Ask for target group(s) to deploy
	# Deploy
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup FMODE FAPPS

        F_LOG $FUNCNAME "DEPLOYAPPSUBSET=$DEPLOYAPPSUBSET"
        FMODE=$1
        FAPPS="$2"

        F_HOSTFILE $FMODE
        while [ -z "$HOSTSELECT" ];do
            if [ "$RUNMODE" == "interactive" ]&&[ -z "$FMODE" ];then 
                HOSTSELECTION=$(F_TARGETS checklist)
            else
                HOSTSELECTION=$(F_TARGETS checklist $BTARGET)
                SUBSETAPPS="$BDEPAPP"
            fi
            
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	if [ "$ABORTED" -eq 0 ];then
	    for rolesapp in $(find ${ROLEDIR}/apps -maxdepth 1 -type d |egrep -v "(template|file|vars|tasks)");do
			F_APPTPLUPDATE "${ROLEDIR}/apps/app.template/tasks" "$rolesapp/tasks"
	    done
	    F_LOG "$FUNCNAME" "Re-creating deployment playbook to reflect any manual changes.. "

            [ $DEPLOYAPPSUBSET == 0 ] && DEPTYPE="'deploy_type':'all'" && SUBSETAPPS=".*"
            if [ $DEPLOYAPPSUBSET == 1 ];then 
                LNKAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2)
                F_LOG $FUNCNAME "Linked apps:\n$LNKAPPS"
                OPTIONS=($(for gapp in $LNKAPPS;do echo ${gapp##*/} "App" off; done))
                unset APPANS
                if [ "$RUNMODE" == "interactive" ]&&[ "$FMODE" != "auto" ];then
                    while [ -z "$APPANS" ];do
                        APPANS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted on app selection" && return 9
                        [ ! -z "$APPANS" ] && SUBSETAPPS=$(echo "$APPANS" | sed 's/$/$/g;s/\ /|/g')
                    done
                else
                    F_LOG $FUNCNAME "running in automatic or non-interactive mode ($RUNMODE, $FMODE)"
                    [ ! -z $FAPPS ] && SUBSETAPPS="$FAPPS"
                fi

                F_LOG $FUNCNAME "Selected apps for deploy:\n$SUBSETAPPS"
                DEPTYPE="'deploy_type':'custom','deploy_sub_apps':'$SUBSETAPPS'"
                DEPAPPS="$SUBSETAPPS"
            fi
            # CLEAN previous deploy app playbook
            [ -f $AINVENTORY/$TARGETENV/$PBDEPLAPP ] && rm $AINVENTORY/$TARGETENV/$PBDEPLAPP && F_LOG "$FUNCNAME" "Deleted previous temp playbook"

            F_LOG $FUNCNAME "will exec: $A2BIN -i $HOSTFILE $PBREGENDEPLOY -e \"target=repository target_env=$TARGETENV $DEPTYPE\""
            F_A2BIN $HOSTFILE $PBREGENDEPLOY "Regenerating temporary deploy-app playbook.." "-e {'target':'repository','target_env':'$TARGETENV',$DEPTYPE}"
		
            DEPAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 1-2 | egrep "($SUBSETAPPS)" | sed 's/^/\\n - /g')
            [ -z "$DEPAPPS" ] && F_LOG $FUNCNAME "ERROR: No app found for deployment" && return 99
            F_LOG $FUNCNAME "Will deploy these apps on $HOSTSELECTION:\n$DEPAPPS"

            [ "$RUNMODE" == "interactive" ] && F_DIALOG --scrollbar --colors --yesno "PORS will deploy on\Zb\Z1\n\n   $HOSTSELECTION\n\n\Znthe following apps (use Page-up/-down to scroll, select <yes> to proceed):\Zb\Z4\n$DEPAPPS\n\n\ZnAre you sure?" 40 100
            if [ $? -eq 0 ]||[ "$RUNMODE" == "batch" ];then
		    for tgroup in $HOSTSELECTION;do
			# CHECK first!
			F_LOG $FUNCNAME "will exec: $A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e 'target=$tgroup accept_hostkey=true' --tags $tgroup"
			#$A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup | tee -a $LOG
			#$A2BIN -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup 2>&1 | tee -a $LOG
			F_A2BIN $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP "Deploying <$tgroup>..." "-e {'target':'$tgroup','accept_hostkey':'true'} --tags $tgroup"
                        ERRCODE=$?
                        F_LOG $FUNCNAME "deploying\n\n$DEPAPPS\n\nto $tgroup ended with $ERRCODE"
                        if [ $ERRCODE -eq 0 ];then    
                            for app in $(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2 | tr -d '$');do
                                APPP="$AINVENTORY/$TARGETENV/group_vars/$tgroup/$app"
                                egrep -ql "^\s*delete:\s*[Tt]rue" $APPP && F_LOG $FUNCNAME "$app has been removed on $tgroup. removing local link..." && rm -vf $APPP 2>&1 >> $LOG
                            done
		            [ "$RUNMODE" == "interactive" ] && F_ERRLOG "$ERRCODE" "<deploying apps to $tgroup>" "$LOG"
                            # always end with errcode 0
                            true
                        else
		            [ "$RUNMODE" == "interactive" ] && F_ERRLOG "$ERRCODE" "<deploying apps to $tgroup>" "$LOG"
                        fi
		    done
            else
                F_ERRLOG 3 "Aborted by user\n" "$LOG"
            fi
	fi
        LASTERR=$?
        F_LOG $FUNCNAME "ended with $LASTERR"
        return $LASTERR
}


## @fn F_CLUSTER()
## @brief Indexer cluster menu
## @exception When no valid answer given returning to MAIN menu
## @details Provides a menu for several cluster tasks 
F_CLUSTER(){ 
        F_LOG $FUNCNAME started
	unset SELECTION
	SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                    	20 90 80 \
                        '' '\Zb\ZuMaintenance\ZB\ZU'\
                        "" "" \
                        OfflinePeer "NOT-READY-YET" \
                        RemovePeer "NOT-READY-YET" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        *)
                        F_ABORTMAINMENU
                        ;;
		esac
	fi
    F_LOG $FUNCNAME ended
}


## @fn F_VMMENU()
## @brief Menu for doing VM tasks
## @exception ..
## @details Provides a menu to deploy VM's and/or configure them
F_VMMENU(){
        F_LOG $FUNCNAME started
        unset SELECTION
        SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuvSphere/ESX operations\ZB\ZU'\
                        "" "" \
                        VM-Deploy "Deploy a new blank VM (OS + ansible-ready)" \
                        Add_newDisk "WIP: add a new disk to an existing VM" \
                        Format_newDisk "WIP: format a (usually) blank disk of an existing VM" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        VM-Deploy)
                        F_DEPLOYVM
                        ;;
                        Add_newDisk)
                        F_ADDDISK
                        ;;
                        Format_newDisk)
                        F_FSDISK
                        ;;
                        *)
                        F_ABORTMAINMENU
                        ;;
                esac
        fi
    F_LOG $FUNCNAME ended
}


## @fn F_CONFMENU()
## @brief Configure splunk server roles
## @exception ..
## @details Provides a menu to configure several splunk server roles
F_CONFMENU(){ 
        F_LOG $FUNCNAME started
        unset SELECTION
        SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        30 100 80 \
                        '' '\Zb\ZuConfigure splunk\ZB\ZU'\
                        "" "" \
                        MasterNode "(re-)apply Indexer MasterNode configuration" \
                        PeerNode "(re-)apply Indexer peernode configuration" \
                        LicenseMaster "(re-)apply LicenseMaster configuration" \
                        DeploymentServer "(re-)apply DeploymentServer configuration" \
                        SearchHead "(re-)apply Standalone (i.e not-clustered) SearchHead configuration" \
                        HeavyForwarder "(re-)apply HeavyForwarder configuration" \
                        Deployer "(re-)apply Deployer configuration" \
                        SHCmember "(re-)apply SearchHead Cluster member configuration" \
                        MonitoringConsole "(re-)apply MonitoringConsole configuration" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        SearchHead)        F_ADDSH ;;
                        PeerNode)          F_ADDPEER ;;
                        MasterNode)        F_ADDMN ;;
                        MonitoringConsole) F_ADDMC ;;
                        HeavyForwarder)    F_ADDHF ;;
                        LicenseMaster)     F_ADDLM ;;
                        Deployer)          F_ADDDEP ;;
                        DeploymentServer)  F_ADDDS ;;
                        SHCmember)         F_ADDSHCMEMBER ;;
                        *) F_ABORTMAINMENU ;;
                esac
        fi
    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYKEY()
## @brief Deploy a key to one or multiple targets
## @param1 source hostname (as in ansible hosts file)
## @param2 destination target group
## @exception ..
## @details Deploys the public key into etc/auth/distServerKeys/{source}.
## This allows to add the remote host as a search peer.
F_DEPLOYKEY(){
    F_LOG $FUNCNAME started
    unset SRCNAME
    
    SRCNAME="$1"
    DESTGRP="$2"

    if [ -z "$SRCNAME" ]||[ -z "$DESTGRP" ];then
        F_LOG $FUNCNAME "ERROR: Missing param ($SRCNAME, $DESTGRP)"
        return 3
    fi
    
    F_A2BIN "$HOSTFILE" "$PBDEPLOYKEY" "\Za\Z1Key deployment running ...\Z\n" "-e {'target_group':'$DESTGRP'} --limit $SRCNAME"
    F_ERRLOG "${PIPESTATUS[0]}" "Deploying key of: $SRCNAME" "$LOG"

    F_LOG $FUNCNAME ended
} 


## @fn F_ADDDEP()
## @brief Configures splunk to be a SHC Deployer
## @exception ..
## @details ..
F_ADDDEP(){
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS="$(F_EXPANDHOSTS deployer $ITMPGRP | sed 's/.*deployer//g')"
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)

    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$HOSTSELECTION" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    # target env must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

    echo '[deployer]' >> $ITMPGRP
    for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need LM and MN in any case:
    echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Will configure deployer on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SHC Deployer. Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBCONFDEP --limit deployer"

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFDEP" "\Za\Z1Configure ...\Z\n" "--limit deployer"
    F_ERRLOG "$?" "configuration SHC Deployer on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDLM()
## @brief Configures splunk to be a LicenseMaster
## @exception ..
## @details ..
F_ADDLM(){
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS="$(F_EXPANDHOSTS licensemaster $ITMPGRP | sed 's/.*licensemaster//g')"
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)

    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$HOSTSELECTION" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    # target env must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

    echo '[pors_lm]' >> $ITMPGRP
    for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the MN in any case:
    echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Will configure LicenseMaster on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas license master. Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit pors_lm"

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFLM" "\Za\Z1Configure ...\Z\n" "--limit pors_lm"
    F_ERRLOG "$?" "configuration LicenseMaster on:\n\n$SHOSTST" "$LOG"
    #F_ERRLOG "${PIPESTATUS[0]}" "configuration LicenseMaster on:\n\n$SHOSTST" "$LOG"

    # FIXME: might be not needed anymore: deploy pub key for dist search
    #PEERS=$(F_EXPANDHOSTS peernode $ITMPGRP | sed 's/site._.*//g')
    #for p in $PEERS;do F_DEPLOYKEY $SHOSTST $p ; done

    unset LISTTYPE
    F_LOG $FUNCNAME ended
}

## @fn F_ADDMN()
## @brief Configures splunk to be a MasterNode
## @exception ..
## @details ..
F_ADDMN(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS="$(F_EXPANDHOSTS masternode $ITMPGRP | sed 's/masternode//g')"
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)

    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$HOSTSELECTION" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    # target env must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

    echo '[pors_masternode]' >> $ITMPGRP
    for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the LM in any case:
    echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Will configure indexer MasterNode on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer masternode. Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit pors_masternode"

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFMN" "\Za\Z1Configure ...\Z\n" "--limit pors_masternode"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer MasterNode on:\n\n$SHOSTST" "$LOG"

    # FIXME: deploy pub key for dist search (useless here? IDX are likely not setup yet
    #PEERS=$(F_EXPANDHOSTS peernode $ITMPGRP | sed 's/site._.*//g')
    #for p in $PEERS;do F_DEPLOYKEY $SHOSTST $p ; done

    unset LISTTYPE
    F_LOG $FUNCNAME ended
}

## @fn F_GETSITES()
## @brief Get all configured sites from a host file
## @exception ..
## @details ..
F_GETSITES(){
    F_LOG $FUNCNAME started
    SITES=$(egrep '^\[site.*_.*\]' $HOSTFILE | tr -d "[" |tr -d "]" | cut -d "_" -f 1 | sort -u)

    F_LOG $FUNCNAME "found these sites: $SITES"
    echo "$SITES"

    F_LOG $FUNCNAME ended
}


## @fn F_ADDMC()
## @brief Configures a new peer as MonitoringConsole
## @exception ..
## @details ..
F_ADDMC(){
    F_LOG $FUNCNAME started
    unset SITESEL HOSTSELECTION OPTIONS SHOSTS SHOSTST ASITES SITEMON

    WHAT=monitoringconsole

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    while [ -z "$SITESEL" ];do
        OPTIONS=($(echo "none one_for_all_sites on";for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITESEL=$(F_DIALOG --radiolist "Please choose a site.\n\nNOTE: The $WHAT might be NOT site specific in your environment. If so choose 'none' here.\n\nIn other words: if you want to use 1 MC for all sites choose 'none'." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$SITESEL" ] && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    if [ "$SITESEL" == "none" ];then
        TG=$WHAT
    else
        TG="${SITESEL}_${WHAT}"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS=$(F_EXPANDHOSTS ${TG} $ITMPGRP | sed "s/$TG//g")
    while [ -z "$HOSTSELECTION" ];do
        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        HERR=$?
        [ $HERR -eq 0 ] && [ ! -z "$HOSTSELECTION" ] && continue
        [ $HERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g')

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"; F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    while [ -z "$SITEMON" ];do
        OPTIONS=($(for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITEMON=$(F_DIALOG --checklist "The MC should monitor hosts in which site(s)?\n\nNOTE: The $WHAT might be used to monitor specific sites only. Select one ore more sites." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        SERR=$?
        [ $SERR -eq 0 ] && [ ! -z "$SITEMON" ] && continue
        [ $SERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done

    F_LOG "$FUNCNAME" "Will configure $WHAT on <$HOSTSELECTION>"
    [ $RUNMODE != "batch" ] && F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas ${WHAT}. Are you sure?" 30 100
    [ $? -ne 0 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\n... preparing all requirements" 5 35

    > ${ITMPGRP}_dep
    > ${ITMPGRP}_peers
    > ${ITMPGRP}_shcm
    > ${ITMPGRP}_hf

    for site in $SITEMON;do
        # site aware deployer
        F_EXPANDHOSTS ${SITEMON}_deployer "${ITMPGRP}_dep" 1> /dev/null 2>>$LOG
        cat ${ITMPGRP}_dep | sed "s/${SITEMON}_deployer/deployer/g" >> $ITMPGRP

        # site aware peernodes
        F_EXPANDHOSTS ${SITEMON}_peernode "${ITMPGRP}_peers" 1> /dev/null 2>>$LOG
        cat ${ITMPGRP}_peers | sed "s/${SITEMON}_peernode/peernode/g" >> $ITMPGRP

        # site aware shc members
        F_EXPANDHOSTS ${SITEMON}_shcmember "${ITMPGRP}_shcm" 1> /dev/null 2>>$LOG
        cat ${ITMPGRP}_shcm | sed "s/${SITEMON}_shcmember/shcmember/g" >> $ITMPGRP

        # site aware heavyforwarders
        F_EXPANDHOSTS ${SITEMON}_heavyforwarder "${ITMPGRP}_hf" 1> /dev/null 2>>$LOG
        cat ${ITMPGRP}_hf | sed "s/${SITEMON}_heavyforwarder/heavyforwarder/g" >> $ITMPGRP
    done

    F_EXPANDHOSTS deploymentserver "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS heavyforwarder "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS activeinput "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS httpeventcollector "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    # target environment must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

    # we need the MN and LM in any case:
    F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    F_LOG $FUNCNAME "Temporary generated group:\n$(cat $ITMPGRP)"
    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBCONFMC --limit $WHAT"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFMC" "\Za\Z1Configure ...\Z\n" "--limit $WHAT"
    CONERR=$?
    [ $CONERR -ne 0 ] && F_LOG "$FUNCNAME" "aborted due to an error on configure playbook ($CONERR)" && F_ERRLOG $CONERR "issue during configuration" $LOG && return $CONERR
    F_LOG $FUNCNAME "Finished configuration successfully.."

    # Add to monitoring
    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBCONFMC --limit $WHAT"
    GRPS="deployer peernode shcmember heavyforwarder deploymentserver heavyforwarder activeinput httpeventcollector masternode licensemaster"
    DERR=0
    for t in $GRPS;do
        F_LOG $FUNCNAME "will exec: F_A2BIN $ITMPGRP $PBDEPLMONKEY 'Deploying MC key ...' -e {'target':'$t'} --limit $WHAT"
        F_A2BIN "$ITMPGRP" "$PBDEPLMONKEY" "\Za\Z1Deploying MC key ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Failed to setup monitoring for: $t" && DERR=1 && break
    done
    [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR

    # configure MC as MC
    DERR=0
    F_A2BIN "$ITMPGRP" "$PBCONFMC" "\Za\Z1Setup MC ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
    [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR

    # TODO: restart all GRPS
    GRPCOL=$(echo "$GRPS" | tr " " ":")
    DERR=0
    F_DIALOG --scrollbar --yesno "\n\nMonitoringConsole setup finished. To fully enable monitoring access splunk must be RESTARTED on all configured hosts: \n\n$GRPS\n\nIf you skip this step you have to configure the MC roles by yourself.\n\nSo, should I splunk restart all these hosts?" 30 100
    if [ $? -ne 0 ];then 
        F_LOG "$FUNCNAME" "Aborted by user"
        F_ERRLOG 4 "ABORTED by user - configuration as $WHAT on:\n\n$SHOSTST" "$LOG"
        return 4
    else
        F_LOG $FUNCNAME "will exec: F_A2BIN $ITMPGRP $PBSPLACT 'Reloading splunk ...' -e {'splunk_action':'reload_all','shelper':'True'} --limit $GRPCOL"
        F_A2BIN "$ITMPGRP" $PBSPLACT "\Za\Z1Reloading splunk ...\Z\n" "-e {'splunk_action':'reload_all','shelper':'True'} --limit $GRPCOL"
        [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR
        # auto-configure MC roles
        DERR=0
        F_LOG $FUNCNAME "will exec: F_A2BIN $ITMPGRP $PBCONFMONROLES 'Setting up MC Roles ...' -e {'target':'$t'} --limit $WHAT"
        F_A2BIN "$ITMPGRP" "$PBCONFMONROLES" "\Za\Z1Setting up MC Roles ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
        [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR
    fi
    
    F_ERRLOG $? "configuration as $WHAT on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDDS()
## @brief Configures a new peer as SearchHead DeploymentServer
## @exception ..
## @details ..
F_ADDDS(){
    F_LOG $FUNCNAME started
    unset SITESEL HOSTSELECTION OPTIONS SHOSTS SHOSTST ASITES

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    while [ -z "$SITESEL" ];do
        OPTIONS=($(echo "none one_for_all_sites on"; for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITESEL=$(F_DIALOG --radiolist "Please choose a site you want to configure.\n\nNOTE: The DS might be not site specific in your environment. If so choose 'none' here." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        SERR=$?
        [ $SERR -eq 0 ] && [ ! -z "$SITESEL" ] && continue
        [ $SERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    if [ "$SITESEL" == "none" ];then
        TG=deploymentserver
    else
        TG="${SITESEL}_deploymentserver"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS=$(F_EXPANDHOSTS ${TG} $ITMPGRP | sed "s/$TG//g")
    while [ -z "$HOSTSELECTION" ];do
        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        HERR=$?
        [ $HERR -eq 0 ] && [ ! -z "$HOSTSELECTION" ] && continue
        [ $HERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g')

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"; F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby.. (setting up some magic)" 5 45

    echo -e '\n[deploymentserver]' >> $ITMPGRP
    for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # target environment must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

    # we need the MN and LM in any case:
    F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Will configure deploymentserver on <$HOSTSELECTION>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas Deploymentserver. Are you sure?" 30 100
    [ $? -ne 0 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4

    F_LOG $FUNCNAME "Temporary generated group:\n$(cat $ITMPGRP)"
    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBCONFDS --limit deploymentserver"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFDS" "\Za\Z1Configure ...\Z\n" "--limit deploymentserver"
    F_ERRLOG "$?" "configuration as Deploymentserver on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDSHCMEMBER()
## @brief Configures a new peer as SearchHead Cluster Member
## @exception ..
## @details ..
F_ADDSHCMEMBER(){
    F_LOG $FUNCNAME started

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    OPTIONS=($(for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
    SITESEL=$(F_DIALOG --radiolist "Please choose a site you want to configure.\n\nNOTE: It is not possible to configure multiple sites in one run." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    
    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
   
    SHOSTS="$(F_EXPANDHOSTS ${SITESEL}_shcmember $ITMPGRP | sed 's/site._.*//g')"
    #[ "$SHOSTS" == ABORTED ] && return 4
 
    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection.\n\nNOTE: It is not possible to configure multiple sites in one run so you will see here $SITESEL hosts only." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g')
    
    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby.. (setting up some magic)" 5 45

    # site aware deployer
    F_EXPANDHOSTS ${SITESEL}_deployer "${ITMPGRP}_dep" 1> /dev/null 2>>$LOG
    cat ${ITMPGRP}_dep | sed "s/${SITESEL}_deployer/deployer/g" >> $ITMPGRP

    # site aware peernodes
    F_EXPANDHOSTS ${SITESEL}_peernode "${ITMPGRP}_peers" 1> /dev/null 2>>$LOG
    cat ${ITMPGRP}_peers | sed "s/${SITESEL}_peernode/peernode/g" >> $ITMPGRP

    echo -e '\n[shcmember]' >> $ITMPGRP
    for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi
    
    # target environment must be set always
    echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP
    
    # we need the MN and LM in any case:
    F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
    
    F_LOG "$FUNCNAME" "Will configure shc member on <$HOSTSELECTION>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SHC member. Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU
    
    F_LOG $FUNCNAME "Temporary generated group:\n$(cat $ITMPGRP)"
    
    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBCONFSHCM --limit shcmember"
    
    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFSHCM" "\Za\Z1Configure ...\Z\n" "--limit shcmember"
    F_ERRLOG "$?" "configuration as SHC member on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDPEER()
## @brief Configures a new peer to an existing indexer cluster
## @exception ..
## @details Configures a new peer to an existing indexer cluster 
F_ADDPEER(){
        F_LOG $FUNCNAME started

	unset SHOSTS SHOSTST HOSTSELECTION ITMPGRP

        # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
        > $ITMPGRP

        [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
        SHOSTS="$(F_EXPANDHOSTS peernode $ITMPGRP | sed 's/site._.*//g')"
        [ "$SHOSTS" == ABORTED ] && return 4

        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)

        SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

        if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
                F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi

        echo -e '\n[peernode]' >> $ITMPGRP
        for h in $SHOSTST;do echo "$h" >> $ITMPGRP; done
        if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

        # target environment must be set always
        echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" >> $ITMPGRP

        # we need the MN and LM in any case:
        F_EXPANDHOSTS masternode "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
        F_EXPANDHOSTS licensemaster "$ITMPGRP" 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP

        #LMHOST=$(F_SELHOST licensemaster)
        #MNHOST=$(F_SELHOST masternode)
        #echo -e '\n[masternode]' >> $ITMPGRP
        #echo "$MNHOST" >> $ITMPGRP
        #echo -e '\n[licensemaster]' >> $ITMPGRP
        #echo "$LMHOST" >> $ITMPGRP

        F_LOG "$FUNCNAME" "Will configure indexer peernode on <$HOSTSELECTION>"
        F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer peernode(s). Are you sure?" 30 100
        [ $? -ne 0 ] && F_ABORTMAINMENU

        F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

        F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

        # doit
        F_A2BIN "$ITMPGRP" "$PBCONFPEER" "\Za\Z1Configure ...\Z\n" "--limit peernode"
        F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer peernode on:\n\n$SHOSTST" "$LOG"

        F_LOG $FUNCNAME ended	
}

## @fn F_ADDSH()
## @brief Configures splunk to be a SearchHead
## @exception ..
## @details ..
F_ADDSH(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST

    SHOSTS="$(F_SELHOST)"
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a SearchHead"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SearchHead(s). Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

    echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
    echo '[searchhead]' >> $ITMPGRP
    for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the MN and LM in any case:
    LMHOST=$(F_SELHOST licensemaster)
    MNHOST=$(F_SELHOST masternode)
    PNHOST=$(F_SELHOST peernode)
    echo -e '\n[peernode]' >> $ITMPGRP
    for h in $PNHOST ;do
        echo "$h" >> $ITMPGRP
    done
    echo -e '\n[masternode]' >> $ITMPGRP
    echo "$MNHOST" >> $ITMPGRP
    echo -e '\n[licensemaster]' >> $ITMPGRP
    echo "$LMHOST" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFSH" "\Za\Z1Configure ...\Z\n" "--limit searchhead"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as SearchHead on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDHF()
## @brief Configures splunk to be a Heavy Forwarder
## @exception ..
## @details ..
F_ADDHF(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST

    SHOSTS="$(F_SELHOST)"
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a Heavy Forwarder"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas Heavy Forwarder(s). Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

    echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
    echo '[heavyforwarder]' >> $ITMPGRP
    for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the MN and LM in any case:
    LMHOST=$(F_SELHOST licensemaster)
    MNHOST=$(F_SELHOST masternode)
    PNHOST=$(F_SELHOST peernode)
    echo -e '\n[peernode]' >> $ITMPGRP
    for h in $PNHOST ;do
        echo "$h" >> $ITMPGRP
    done
    echo -e '\n[masternode]' >> $ITMPGRP
    echo "$MNHOST" >> $ITMPGRP
    echo -e '\n[licensemaster]' >> $ITMPGRP
    echo "$LMHOST" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFHF" "\Za\Z1Configure ...\Z\n" "--limit heavyforwarder"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as Heavy Forwarder on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}


## @fn F_VAULTPW()
## @brief Ask for the Vault password if required
## @exception ..
## @details Ansible Vault dialog to grab the pass and store it temporary
## After using this you HAVE TO ensure using F_RMVAULTPW after the pw file is not needed anymore.
F_VAULTPW(){ 
    F_LOG $FUNCNAME started

    RETRY=1

    # skip if we do not have vault enabled
    [ "$ENABLEVAULT" != "yes" ] && F_LOG $FUNCNAME "skipping vault request as ENABLEVAULT is not yes" && return 0

    # skip if vault tmp file exists
    [ -s "$VAULTTEMPFILE" ] && F_LOG $FUNCNAME "skipping vault request as vault temp file exists already" && return 0

    while [ $RETRY -ne 0 ];do
        FPW=$(F_DIALOG --insecure --mixedform \
                "\nAnsible Vault is enabled (ENABLEVAULT variable).\nPlease type in the Vault password to unlock protected variables:\n" 10 80 0 \
                "Password:" 1 1 '' 1 20 20 0 1 \
                 2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4

        # write the vault temp file
        echo "$FPW" > $VAULTTEMPFILE 2>> $LOG

        F_LOG $FUNCNAME "will test given password on: $DEFAULTVAULT"
        $VBINX view $DEFAULTVAULT --vault-password-file $VAULTTEMPFILE 1> /dev/null 2>> $LOG
        if [ $? -ne 0 ];then
            RETRY=1
            F_DIAERR 9 "Oops password is incorrect. Try again.."
            unset FPW
            rm $VAULTTEMPFILE
        else
            RETRY=0
        fi
    done

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_VCDEFS()
## @brief Collects every PORS relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/vmware (defined in $PBVCINFO playbook)
F_VSPHERE_VCDEFS(){ 
    F_LOG $FUNCNAME started
    F_A2BIN $HOSTFILE $PBVCSHOW "Collecting vCenter definitions..."
    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_VCGETINFO()
## @brief Collects and sets every PORS relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/tmp (defined in $PBVCINFO playbook) and let the user choose from it
F_VSPHERE_VCGETINFO(){ 
    F_LOG $FUNCNAME started
    VCWORKDIR="$AINVENTORY/$TARGETENV/tmp"

    F_LOG $FUNCNAME $VMCPU

    # collect configured vcenter definitions
    F_VSPHERE_VCDEFS
    VERR=$?
    [ $VERR -ne 0 ] && F_DIAERR $VERR "ERROR: during F_VSPHERE_VCDEFS" && return 3

    OPTIONS=($(for i in $(cat $VCWORKDIR/vcenters.list);do echo "${i/*:}" "${i/:*}" off;done))
    VCENTER=$(F_DIALOG --radiolist \
            "\nThese are the currently defined vCenters\n($INVENTORY/$TARGETENV/group_vars/all/bare_install)\n\nPlease use the space-bar to make your selection:" \
            80 80 70 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_DIAERR 3 "During VCENTER selection" && return 4

    F_LOG $FUNCNAME "Choosen vCenter was: $VCENTER"   
 
    # check previous lists, if one of them is not here or 0 bytes a refresh will be forced
    VCLIST="$VCWORKDIR/vcenters.list"
    VCHOSTLIST="$VCWORKDIR/${VCENTER}_vchosts.list"
    VCNETLIST="$VCWORKDIR/${VCENTER}_networks.list"
    VCDCLIST="$VCWORKDIR/${VCENTER}_datacenters.list"
    VCDSLIST="$VCWORKDIR/${VCENTER}_datastores.list"
    VCREFRESH=0

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -eq 1 ];then
        F_DIALOG --colors --yesno "\nPORS has detected cached vCenter information for:\n\n     \Zb$VCENTER\ZB\n\nDo you want to use the cache (choose: yes)\nor force a refresh (choose: no)?\n" 13 80
        VCREFRESH=$?
    fi
    if [ $LISTSAVAIL -eq 0 -o $VCREFRESH -eq 1 ];then
        F_A2BIN $HOSTFILE $PBVCINFO "Collecting vCenter information ..." "-e {'vsphere_var':'$VCENTER'}"
    else
        F_LOG $FUNCNAME "Using cached vCenter lists but refreshing vhosts (always)"
        F_A2BIN $HOSTFILE $PBVCGETVHOSTSTATES "Collecting vhosts states ..." "-e {'vsphere_var':'$VCENTER'}"
    fi

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -ne 1 ];then
        F_ERRLOG "9" "Error collecting ESX information!" "$LOG"
        F_ABORTMAINMENU
    fi

    # Target ESX
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCHOSTLIST);do echo "${i/;*}" "${i/*;}" off;done))
        VCHOST=$(F_DIALOG --colors --radiolist \
            "\nThe following ESX hosts are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCHOST"
        HOSTFILTER=$(echo $VCHOST | cut -d "." -f1)
        [ ! -z "$VCHOST" ] && FINISHED=1
    done

    # Target Network name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCNETLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCNET=$(F_DIALOG --colors --radiolist \
            "\nThe following Networks are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCNET"   
        [ ! -z "$VCNET" ] && FINISHED=1
    done

    # Target Datacenter name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDCLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCDC=$(F_DIALOG --colors --radiolist \
            "\nThe following Datacenters are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDC"
        [ ! -z "$VCDC" ] && FINISHED=1
    done

    # Target Datastore name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
        VCDS=$(F_DIALOG --colors --radiolist \
            "\nThe following Datastorages are handled by the choosen vCenter (\Zb$VCENTER\ZB)\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n\nThe datastorage to store the\n\n   \ZbOperating System\ZB\n\n should be:\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDS"   
        [ ! -z "$VCDS" ] && FINISHED=1
    done

    # DEPLOY IT
    F_VSPHERE_DEPLOY
    ERR=$?
    F_LOG $FUNCNAME "F_VSPHERE_DEPLOY ended with $ERR"
    return $ERR

    F_LOG $FUNCNAME ended
} 

## @fn F_VSPHERE_SELDS()
## @brief Select a datastore of a given vCenter
## @param 1 (exported) VCENTER
## @param 2 (exported) VCDSLIST
## @param 1 (exported) VMDISKDEV
## @param 1 (exported/optional) VMDISKMNTP
## @param 1 (exported) VMDISKSIZEGB
## @return name of datastore 
## @details Select a datastore of a given vCenter for a specific disk
F_VSPHERE_SELDS(){
    F_LOG $FUNCNAME started

    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
        VCDS=$(F_DIALOG --colors --radiolist \
                "\nThe following Datastorages are handled by the choosen vCenter ($VCENTER)\n\nWhich one of the following should be used for\n\n  \Zb${!VMDISKDEV} ${!VMDISKMNTP} (${!VMDISKSIZEGB} GB)\ZB\n\n(space-bar selects)?\n" \
                100 80 100 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "ERROR $? - aborted by user" && return 99
        F_LOG $FUNCNAME "Choosen: $VCDS"
        [ ! -z "$VCDS" ] && FINISHED=1
    done
    echo "$VCDS"

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_DEPLOY()
## @brief Deploys the vSphere VM
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_VSPHERE_DEPLOY(){ 
    F_LOG $FUNCNAME started

    F_LOG "$FUNCNAME" "VCENTER,VMHOST,VMCPU,VMRAM_MB,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN,VCHOST,VCDC,VCDS,VCNET,VMGUESTOS,VMDISK,VMDISKTYPE,VMDISKSIZEGB,VMDISKOPTS,VMDISKDEV"
    F_LOG "$FUNCNAME" "$VCENTER,$VMHOST,$VMCPU,$VMRAM_MB,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN,$VCHOST,$VCDC,$VCDS,$VCNET,$VMGUESTOS,$VMDISK,$VMDISKTYPE,$VMDISKSIZEGB,$VMDISKOPTS,$VMDISKDEV"

    if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM_MB" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" -o -z "$VMSDOMAIN" -o -z "$VCHOST" -o -z "$VCDC" -o -z "$VCDS" -o -z "$VCNET" ];then
        F_DIAERR 9 "A required field is missing! ABORTED."
        F_LOG $FUNCNAME "ERROR: A required field is missing!"
        F_ABORTMAINMENU
    else            
        ABORTED=0
    fi

    # make all user defined settings available here
    source $TMPHWPROFILE

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nPORS is about to provision a VM with the following details:\n\n    vCenter:"$'\t\t'"\Zb$VCENTER\ZB\n    ESX:"$'\t\t'"$VCHOST\n\n    Hostname:"$'\t\t'"${VMHOST}.${VMSDOMAIN}\n    CPU:"$'\t\t'"$VMCPU\n    RAM:"$'\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t'"$VMIP/$VMNETMASK\n    Gateway:"$'\t\t'"$VMGW\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n    Datacenter:"$'\t'"$VCDC\n    Datastorage:"$'\t'"$VCDS\n    Network:"$'\t\t'"$VCNET\n\nDo you want to continue?\n" 50 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 99

    F_LOG $FUNCNAME "Will start provisionining with: $PBVCVMDEPLOY -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM_MB','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS', 'server_scnd_disk':'$VMDISK','server_disk_type':'$VMDISKTYPE','server_disk_sizegb':'$VMDISKSIZEGB'}"

    F_A2BIN $HOSTFILE $PBVCVMDEPLOY "Deploying $VMHOST to $VCHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM_MB','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS','server_scnd_disk':'$VMDISK'}" 
#2>&1 >> $LOG
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"
    F_DIAERR $DEPERR "Deploying $VMHOST to $VCENTER" 
    [ $DEPERR -ne 0 ] && return 99

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # add as many disk(s) as needed

        VMDISKCNT=0
        while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))

            # dynamic variable names..
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"

            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

            # Target Datastore name
            FINISHED=0    
            while [ $FINISHED -eq 0 ];do        
                OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
                VCDS=$(F_DIALOG --colors --radiolist \
                "\nThe following Datastorages are handled by the choosen vCenter ($VCENTER)\n\nWhich one of the following should be used for\n\n  \Zb${!VMDISKDEV} - ${!VMDISKMNTP} (${!VMDISKSIZEGB} GB)\ZB\n\n(space-bar selects)?\n" \
                100 80 100 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)
                [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
                F_LOG $FUNCNAME "Choosen: $VCDS"
                [ ! -z "$VCDS" ] && FINISHED=1
            done

            # sum up (makes uses of real tab spaces in dialog):
            F_DIALOG --no-collapse --colors --yesno "\nPORS is about to add a new disk to VM $VMHOST with the following details:\n\n    vCenter:"$'\t\t'"\Zb$VCENTER\ZB\n    ESX:"$'\t\t'"$VCHOST\n\n    Hostname:"$'\t\t'"${VMHOST}.${VMSDOMAIN}\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM VG name: "$'\t'"${!VMDISKLVMVG}\n    LVM LV name: "$'\t'"${!VMDISKLVMLV}\n    Datacenter:"$'\t'"$VCDC\n    Datastorage:"$'\t'"$VCDS\n\nDo you want to continue?\n" 50 80
            DEPLOYIT=$?

            [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 99

            F_LOG $FUNCNAME "additional disk config needed. disks left: $VMDISK"
            #F_LOG $FUNCNAME "will call $PBVMNEWDISK with: 'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','vsphere_datastore':'$VCDS','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_scsi_controller':'$VMSCSI','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}'"

            F_A2BIN $HOSTFILE $PBVMNEWDISK "Adding a new disk to $VMHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','vsphere_datastore':'$VCDS','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_scsi_controller':'$VMSCSI','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}'}"
            ADDERR=$?
            [ $ADDERR -ne 0 ] && F_LOG $FUNCNAME "error $ADDERR occured" && return $ADDERR

            F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))" 
        done
        VMDISKCNT=0
        while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))
            
            # dynamic variable names..
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"
            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
   
            F_A2BIN $HOSTFILE $PBVMDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','vsphere_datastore':'$VCDS','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}','server_lvm_vg':'${!VMDISKLVMVG}','server_lvm_lv':'${!VMDISKLVMLV}'}"
            ERR=$?
            [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR
            
       done
    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_DISKADD()
## @brief TODO/WIP Adds a new disk to a vSphere managed VM
## @param 1 (exported) TMPHWPROFILE
## @param 2 (exported/optional) VMDISK
## @param 3 (exported) VMHOST
## @details Adds a new disk to a vSphere managed VM 
F_VSPHERE_DISKADD(){ 
    F_LOG $FUNCNAME started

    if [ -z "$VMDISK" ];then
        DIAOUT=$(F_DIALOG --form "\nSetup new disk(s) for $VMHOST" 20 100 10  \
                            "How many disks do you want to add?" 1 1 "1" 1 42 40 40  \
                            3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Disk count dialog ended with $?" && return 9
        [ "$DIAOUT" -ge 0 ] && VMDISK="$DIAOUT"
        F_LOG $FUNCNAME "User wants to add: $VMDISK disk(s)"
    fi

    VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"

        VCDS=$(F_VSPHERE_SELDS)

        DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST- Use arrow keys to switch between\n(no validation so be careful what you type..)" 20 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Disk size in GB" 2 1 "${!VMDISKSIZEGB}" 2 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 3 1 "${!VMDISKTYPE}" 3 42 40 16 \
                            3>&1 1>&2 2>&3)

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

        UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
        UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
        UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")

        echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}VCDS=${VCDS}" >> $TMPHWPROFILE

        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}VCDS=${VCDS}"

        F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
    done
    VMERR=$?

    F_LOG $FUNCNAME "ended with $VMERR"
    return $VMERR
}

## @fn F_VSPHERE_DISKSETUP()
## @brief TODO/WIP Formats a partition in a VM incl. setting it up
## @param 1 (exported) TMPHWPROFILE
## @param 2 (exported/optional) VMDISK
## @param 3 (exported) VMHOST
## @param 4 (exported/optional) VMDISKDEV
## @param 5 (exported/optional) VCENTER
## @details Will prepare LVM, format and add to fstab a given partition
## Only vSphere ESX is supported.
F_VSPHERE_DISKSETUP(){
    F_LOG $FUNCNAME started

    if [ -z "$VMDISK" ];then
        DIAOUT=$(F_DIALOG --form "\nSetup new disk(s) for $VMHOST" 20 100 10  \
                            "How many disks do you want to setup?" 1 1 "1" 1 42 40 40  \
                            3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Disk count dialog ended with $?" && return 9
        [ "$DIAOUT" -ge 0 ] && VMDISK="$DIAOUT"
        F_LOG $FUNCNAME "User wants to add: $VMDISK disk(s)"
    fi

    VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
        VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

        DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST- Use arrow keys to switch between\n(no validation so be careful what you type..)" 20 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Filesystem to use (xfs,ext4,..)" 2 1 "${!VMDISKFS}" 2 42 40 20  \
                            "Disk size in GB" 3 1 "${!VMDISKSIZEGB}" 3 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 4 1 "${!VMDISKTYPE}" 4 42 40 16 \
                            "Mountpoint" 5 1 "${!VMDISKMNTP}" 5 42 40 40 \
                            "LVM VG name" 6 1 "${!VMDISKLVMVG}" 6 42 40 40 \
                            "LVM LV name" 7 1 "${!VMDISKLVMLV}" 7 42 40 40 \
                            "Mount options" 8 1 "${!VMDISKOPTS}" 8 42 40 100 \
                            3>&1 1>&2 2>&3)

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

        UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
        UVMDISKFS=$(echo "$NDIAOUT" | cut -d "|" -f 2 | tr -d " ")
        UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
        UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")
        UVMDISKMNTP=$(echo "$NDIAOUT" | cut -d "|" -f 5 | tr -d " ")
        UVMDISKLVMVG=$(echo "$NDIAOUT" | cut -d "|" -f 6 | tr -d " ")
        UVMDISKLVMLV=$(echo "$NDIAOUT" | cut -d "|" -f 7 | tr -d " ")
        UVMDISKOPTS=$(echo "$NDIAOUT" | cut -d "|" -f 8 | tr -d " ")

        echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}FS=${UVMDISKFS}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}" >> $TMPHWPROFILE

        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FS=${UVMDISKFS}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}"

        F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
    done
    VMERR=$?

    F_LOG $FUNCNAME "ended with $VMERR"
    return $VMERR
}

## @fn F_DEPLOYVM()
## @brief Deploy a new blank VM based on a template
## @exception ..
## @details ..
F_DEPLOYVM(){
    F_LOG $FUNCNAME started

    unset PROVIDER RECIPES

    RECIPES=$(find $DATADIR/vm_recipes -type d -maxdepth 1 -mindepth 1)

    while [ -z "$PROVIDER" ];do
        OPTIONS=($(for i in $RECIPES;do echo "${i/*\/}" "$i" off;done))
        PROVIDER=$(F_DIALOG --colors --radiolist \
            "\nPORS hardware profile folders have been found.\nMake your choice!\n\nIf you see 'IaC' here you can re-deploy or base on an already deployed VM.\nChoose 'Empty' if you want to start with an empty template:\n" \
            50 80 100 \
            "${OPTIONS[@]}" \
            "Empty" "Empty template " off \
            2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$PROVIDER" ] && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
   
    F_STARTVMDEP "$DATADIR/vm_recipes/$PROVIDER"

    F_LOG $FUNCNAME ended
}

## @fn F_STARTVMDEP()
## @brief Deploy a new blank VM based on a template
## @exception ..
## @param1 required: target profile vendor (e.g. vmware,proxmox,googlecp,custom,..)
## @details The VM template used to clone.
## should be setup and prepared in a a way that ansible is able
## to connect and work with afterwards.
F_STARTVMDEP(){ 
    F_LOG $FUNCNAME started

    unset SROLE VENDOR VMHOST VMSDOMAIN VMCPU VMRAM_GB VMIP VMNETMASK VMGW VMDNS1 VMDNS2 VM_PROVIDER

    FINISHED=0
    ABORTED=0
    IACKEEP=0

    PROVIDERDIR="$1"

    HWCONFIG="$PROVIDERDIR/pors_hardware-config_"
    IACDIR="${PROVIDERDIR}/../IaC"

    [ ! -d "$PROVIDERDIR" ] && F_ERRLOG 3 "ERROR: cannot find the path specified: $PROVIDER" $LOG && return 3
    [ ! -d "$IACDIR" ] && mkdir $IACDIR && F_LOG $FUNCNAME "created $IACDIR"
    
    for srole in $(cat ${HWCONFIG}*.config |egrep "^SERVER_ROLE=" | cut -d "=" -f 2);do
        SROLE="$SROLE $srole"
    done

    F_LOG $FUNCNAME "Detected hardware profiles: $SROLE"
    
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $SROLE;do echo "$i" "$i" off;done))
        HWPROFILE=$(F_DIALOG --colors --radiolist \
            "\nPORS hardware profiles have been found.\nSelect (space-bar) any or choose 'Empty' \nif you want to start with an empty template:\n" \
            50 80 100 \
            "${OPTIONS[@]}" \
            "Empty" "Empty template " off \
            2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$HWPROFILE" ] && FINISHED=1 && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    F_LOG $FUNCNAME "Choosen hardware profile: $HWPROFILE"
    FINISHED=0

    # load common settings (might get overwritten by role specific ones)
    source ${HWCONFIG}common.config

    if [ "$HWPROFILE" != "Empty" ];then
        if [ ! -f ${HWCONFIG}${HWPROFILE}.config ];then
            F_ERRLOG 9 "Cannot find ${HWCONFIG}${HWPROFILE}.config!"
        else
            F_LOG $FUNCNAME "Loading $HWPROFILE template.."
            source "${HWCONFIG}${HWPROFILE}.config"
        fi
    fi

    # default SCSI controller if not set in the HW profile
    [ -z "$VMSCSI" ] && VMSCSI=0
    # default mount options when additional disk
    [ -z "$VMDISKOPTS" ] && VMDISKOPTS="defaults"

    while [ $FINISHED -eq 0 ];do
        DIAOUT=$(F_DIALOG --form "\nSetup your new VM - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                "Hostname" 1 1 "$VMHOST" 1 20 70 60  \
                "Server Domain Name" 2 1 "$VMSDOMAIN" 2 20 70 60 \
                "CPU count" 3 1 "$VMCPU" 3 20 4 3 \
                "RAM (GB)" 4 1 "$VMRAM_GB" 4 20 10 10 \
                "Host IP (or 'dhcp')" 5 1 "$VMIP" 5 20 27 28 \
                "Netmask (x.x.x.x)" 6 1 "$VMNETMASK" 6 20 27 28 \
                "Gateway IP" 7 1 "$VMGW" 7 20 27 28 \
                "DNS #1" 8 1 "$VMDNS1" 8 20 27 28 \
                "DNS #2" 9 1 "$VMDNS2" 9 20 27 28 \
                "VM Provider" 10 1 "$VM_PROVIDER" 10 20 70 60  \
                3>&1 1>&2 2>&3)
        WERR=$?
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && ABORTED=1 && FINISHED=1 && return 4

        F_LOG $FUNCNAME "diaout:\n$DIAOUT"

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")
        
        VMHOST=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")
        VMSDOMAIN=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")
        VMCPU=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")
        VMRAM_GB=$(echo $NDIAOUT | cut -d "|" -f4 | tr -d " ")
        VMIP=$(echo $NDIAOUT | cut -d "|" -f5 | tr -d " ")
        VMNETMASK=$(echo $NDIAOUT | cut -d "|" -f6 | tr -d " ")
        VMGW=$(echo $NDIAOUT | cut -d "|" -f7 | tr -d " ")
        VMDNS1=$(echo $NDIAOUT | cut -d "|" -f8 | tr -d " ")
        VMDNS2=$(echo $NDIAOUT | cut -d "|" -f9 | tr -d " ")
        VM_PROVIDER=$(echo $NDIAOUT | cut -d "|" -f10 | tr -d " ")

        # prepare IaC config
        VMHOSTWDATE="${VMHOST}_$(date +%Y%m%d-%H%M%S)"
        TMPHWPROFILE=$IACDIR/pors_hardware-config_${VMHOSTWDATE}.config
        [ "$HWPROFILE" != "Empty" ] && touch $TMPHWPROFILE
        cp ${HWCONFIG}${HWPROFILE}.config $TMPHWPROFILE

        F_LOG "$FUNCNAME" "VMHOST,VMCPU,VMRAM_GB,,VMRAM_MB,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN,VM_PROVIDER"
        F_LOG "$FUNCNAME" "$VMHOST,$VMCPU,$VMRAM_GB,$VMRAM_MB,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN,$VM_PROVIDER"

        if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM_GB" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" ];then
            F_DIAERR 9 "A required field is missing.. try again"
            F_LOG $FUNCNAME "ERROR: A required field is missing!"
            VMERR=99
        else
            FINISHED=1
            VMERR=0
            echo -e "\n\n# The following overrides the above defaults\n" >> $TMPHWPROFILE
            case $VM_PROVIDER in
                vsphere|vmware)
                    PROVOUT=$(F_DIALOG --form "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                                "ESXi host" 1 1 "$VM_VSPHERE_ESX" 1 20 27 28 \
                                "Datastore" 2 1 "$VM_VSPHERE_DS" 2 20 70 60  \
                                "Datacenter" 3 1 "$VM_VSPHERE_DC" 3 20 70 60  \
                                "Network Name" 4 1 "$VM_VSPHERE_NETNAME" 4 20 70 60  \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_VSPHERE_ESX=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")              
                    VM_VSPHERE_DS=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")              
                    VM_VSPHERE_DC=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")              
                    VM_VSPHERE_NETNAME=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")

                    echo "VM_VSPHERE_ESX=$VM_VSPHERE_ESX" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_DS=$VM_VSPHERE_DS" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_DC=$VM_VSPHERE_DC" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_NETNAME=$VM_VSPHERE_NETNAME" >> $TMPHWPROFILE
                ;;
                proxmox|pve)
		    F_DIALOG --infobox "\nParsing Ansible variables ..." 5 40
                    # collect available Nodes
                    F_A2BIN $HOSTFILE $PBPVEGETNODES "Collecting Proxmox Nodes.."
                    VM_PVE_NODES=$(cat ${PORS_TEMPDIR}/pve_nodes.lst | tr '\n' ',' | sed 's/,$//g')

                    PROVOUT=$(F_DIALOG --mixedform "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                                "PVE Datacenter/Node" 1 1 "$VM_PROXMOX_NODE" 1 30 27 28 0 \
                                "(available nodes: $VM_PVE_NODES)" 2 1 " " 2 50 0 0 2 \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_PROXMOX_NODE=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")

                    echo "VM_PROXMOX_NODE=$VM_PROXMOX_NODE" >> $TMPHWPROFILE
                ;;
                googlecp|gcp)
                    # collect ansible config
		    F_DIALOG --infobox "\nParsing Ansible variables ..." 5 40
                    F_A2BIN $HOSTFILE $PBGCPGETIDS "Parsing ansible config ..." >> $LOG
                    VM_GOOGLECP_IDS=$(cat ${PORS_TEMPDIR}/googlecp.ids | tr '\n' ',' | sed 's/,$//g')
                    [ -z "$VM_GOOGLECP_MROLE" ] && VM_GOOGLECP_MROLE=$SERVER_ROLE

                    PROVOUT=$(F_DIALOG --mixedform "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                                "GCP project id:" 1 1 "$VM_GOOGLECP_ID" 1 30 27 28 0 \
                                "(available ids: $VM_GOOGLECP_IDS)" 2 1 " " 2 50 0 0 2 \
                                "Machine Type:" 3 1 "$VM_GOOGLECP_MTYPE" 3 30 27 28 0 \
                                "Metadata Role:" 4 1 "$VM_GOOGLECP_MROLE" 4 30 27 28 0 \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_GOOGLECP_ID=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")
                    VM_GOOGLECP_MTYPE=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")
                    VM_GOOGLECP_MROLE=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")

                    echo "VM_GOOGLECP_ID=$VM_GOOGLECP_ID" >> $TMPHWPROFILE
                    echo "VM_GOOGLECP_MTYPE=$VM_GOOGLECP_MTYPE" >> $TMPHWPROFILE
                    echo "VM_GOOGLECP_MROLE=$VM_GOOGLECP_MROLE" >> $TMPHWPROFILE
                    echo 
                ;;
                *) F_DIAERR 4 "ERROR no valid VM provider selected! Check documentation." && VMERR=4 ;;
            esac
 
            [ $VMERR -ne 0 ] && F_LOG $FUNCNAME "ERROR: VMERR=$VMERR" && ABORTED=1 && FINISHED=1 && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 99
            F_LOG $FUNCNAME "diaout:\n$DIAOUT"
        fi

        # add as many disk(s) as needed
        if [ $VMERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
            sed -i "s/^SERVER_ROLE=.*/SERVER_ROLE=${VMHOSTWDATE}/g" $TMPHWPROFILE
            echo "SERVER_ROLE_BASE=$HWPROFILE" >> $TMPHWPROFILE
            echo "VMHOST=$VMHOST" >> $TMPHWPROFILE
            echo "VMCPU=$VMCPU" >> $TMPHWPROFILE
            echo "VMRAM_GB=$VMRAM_GB" >> $TMPHWPROFILE
            VMRAM_MB=$((VMRAM_GB * 1024))
            echo "VMRAM_MB=$VMRAM_MB" >> $TMPHWPROFILE
            echo "VMIP=$VMIP" >> $TMPHWPROFILE
            echo "VMNETMASK=$VMNETMASK" >> $TMPHWPROFILE
            echo "VMGW=$VMGW" >> $TMPHWPROFILE
            echo "VMDNS1=$VMDNS1" >> $TMPHWPROFILE
            echo "VMDNS2=$VMDNS2" >> $TMPHWPROFILE
            echo "VMSDOMAIN=$VMSDOMAIN" >> $TMPHWPROFILE
            echo "VM_PROVIDER=$VM_PROVIDER" >> $TMPHWPROFILE

            VMDISKCNT=0
            while [ $VMDISKCNT -ne $VMDISK ];do
                VMDISKCNT=$((VMDISKCNT +1))

                # dynamic variable names..
                VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
                VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
                VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
                VMDISKDEV="VMDISK${VMDISKCNT}DEV"
                VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"
                VMDISKDEVAUTODEL="VMDISK${VMDISKCNT}DEVAUTODEL"
                VMDISKEXTRANAME="VMDISK${VMDISKCNT}EXTRANAME"
                VMDISKFS="VMDISK${VMDISKCNT}FS"
                VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
                VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
                VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

                DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 40 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Filesystem to use (xfs,ext4,..)" 2 1 "${!VMDISKFS}" 2 42 40 20  \
                            "Disk size in GB" 3 1 "${!VMDISKSIZEGB}" 3 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 4 1 "${!VMDISKTYPE}" 4 42 40 16 \
                            "Mountpoint" 5 1 "${!VMDISKMNTP}" 5 42 40 40 \
                            "LVM VG name" 6 1 "${!VMDISKLVMVG}" 6 42 40 40 \
                            "LVM LV name" 7 1 "${!VMDISKLVMLV}" 7 42 40 40 \
                            "Mount options" 8 1 "${!VMDISKOPTS}" 8 42 40 100 \
                            "Boot device?" 9 1 "${!VMDISKDEVBOOT}" 9 42 40 40 \
                            "Auto delete?" 10 1 "${!VMDISKDEVAUTODEL}" 10 42 40 40 \
                            "Disk extra name" 11 1 "${!VMDISKEXTRANAME}" 11 42 40 40 \
                            3>&1 1>&2 2>&3)
                [ $? -ne 0 ] && F_LOG $FUNCNAME "ABORTED BY USER IN DISK DIALOG" && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 99

                # normalize the output so it can be parsed correctly
                NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

                UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
                UVMDISKFS=$(echo "$NDIAOUT" | cut -d "|" -f 2 | tr -d " ")
                UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
                UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")
                UVMDISKMNTP=$(echo "$NDIAOUT" | cut -d "|" -f 5 | tr -d " ")
                UVMDISKLVMVG=$(echo "$NDIAOUT" | cut -d "|" -f 6 | tr -d " ")
                UVMDISKLVMLV=$(echo "$NDIAOUT" | cut -d "|" -f 7 | tr -d " ")
                UVMDISKOPTS=$(echo "$NDIAOUT" | cut -d "|" -f 8 | tr -d " ")
                UVMDISKBOOTDEV=$(echo "$NDIAOUT" | cut -d "|" -f 9 | tr -d " ")
                UVMDISKAUTODEL=$(echo "$NDIAOUT" | cut -d "|" -f 10 | tr -d " ")
                UVMDISKEXTRANAME=$(echo "$NDIAOUT" | cut -d "|" -f 11 | tr -d " ")

                echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}FS=${UVMDISKFS}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}OPTS=\"${UVMDISKOPTS}\"" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEVBOOT=${UVMDISKDEVBOOT}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEVAUTODEL=${UVMDISKDEVAUTODEL}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}EXTRANAME=${UVMDISKEXTRANAME}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}" >> $TMPHWPROFILE

                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FS=${UVMDISKFS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}"
 
                F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
            done
            VMERR=$?
        else
            F_LOG $FUNCNAME "No additional disk config needed or a prev error occured"
        fi

        if [ $VMERR -eq 0 ];then
            HSETOK=99
            while [ $HSETOK -ne 0 ];do
                grep "${VMHOST}.${VMSDOMAIN}" "$HOSTFILE" -q
                HSETOK=$?
                if [ $HSETOK -ne 0 ];then
                    F_DIALOG --msgbox "\nThe server is not in $HOSTFILE.\nIt must be added now before we can continue.\n\n${VMHOST}.${VMSDOMAIN}\n(mouse to select, ctrl+shift+C to copy)\n\nmust be added to $HOSTFILE before you can continue.\nWhen you press OK $EDITBIN will be used to open it." 16 100
                    $EDITBIN $HOSTFILE
                fi
            done
            case $VM_PROVIDER in
                vsphere|vmware)
                    # switch to vCenter information and actions
                    VCENTER=$(F_VSPHERE_VCGETINFO 2>&1 >/dev/tty)
                    VMERR=$?
                    ;;
                proxmox|pve)
                    F_PROXMOX_DEPLOY "$TMPHWPROFILE"
                    VMERR=$?
                    ;;
                googlecp|gcp)
                    F_GOOGLECP_DEPLOY "$TMPHWPROFILE"
                    VMERR=$?
                    ;;
                    *) F_DIAERR 3 "ERROR no valid VM provider selected! Check documentation." && return 3 ;;
            esac
            F_ERRLOG $VMERR "Deploying $VMHOST" $LOG
            [ -f "$TMPHWPROFILE" ] && F_DIALOG --yesno "\nDo you want to save the hardware profile for\n\n    $VMHOST\n\nas an IaC (Infrastructure as Code) profile?\n\nWhen you select 'yes' you can re-deploy with the same settings when choosing the 'IaC' folder next time." 16 100
            if [ $? -eq 1 ];then 
                rm -vf $TMPHWPROFILE >> $LOG 2>&1
            else
                IACKEEP=1
            fi
        else
            [ $? -eq 1 ] && rm -vf $TMPHWPROFILE >> $LOG 2>&1
        fi
    done

    # install base software not in template, ensure up2date system patches
    if [ $VMERR -eq 0 ];then
        F_BASEINSTALL "${VMHOST}.${VMSDOMAIN}"
        F_DIAERR $? "Base install"
        F_SYSUPGRADE "${VMHOST}.${VMSDOMAIN}"
        F_DIAERR $? "Upgrading System"
    fi
    [ $VMERR -ne 0 ] && [ "$IACKEEP" -ne 1 ] && F_LOG $FUNCNAME "deleting IaC file due to a previous error/abort" && rm $TMPHWPROFILE
    
    # close function when aborted
    [ $ABORTED -eq 1 ] && F_LOG $FUNCNAME "closing func due to abort state" && return 3

    F_LOG $FUNCNAME ended
}

## @fn F_GOOGLECP_DEPLOY()
## @brief Deploys a VM in GCP
## @param1 required: source file containing the hw config
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_GOOGLECP_DEPLOY(){ 
    F_LOG $FUNCNAME started

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nPORS is about to provision an instance with the following details:\n\n    GCP Project:"$'\t'"\Zb$VM_GOOGLECP_ID\ZB\n\n    Hostname:"$'\t\t'"${VMHOSTF}\n    CPU:"$'\t\t'"$VMCPU\n    RAM:"$'\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t'"$VMIP\n    Machine Type:"$'\t'"$VM_GOOGLECP_MTYPE\n    Metadata Role:"$'\t'"$VM_GOOGLECP_MROLE\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n\nDo you want to continue?\n" 30 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 4

    # GCP MUST have vmdisk1 as root device and that is handled different so should not be in DISK_LIST at all
    VMDISKCNT=1
    unset DISK_LIST

    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKEXTRANAME="VMDISK${VMDISKCNT}EXTRANAME"
        VMDISKDEVAUTODEL="VMDISK${VMDISKCNT}DEVAUTODEL"
        VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"

        # gen disk name from mnt point
        VMDISKNAME=$(echo "${!VMDISKMNTP}" | sed 's/.*\///g')
        [ -z "$VMDISKNAME" ] && VMDISKNAME=$(echo "${!VMDISKFS}" | sed 's/.*\///g')
        [ "$VMDISKFS" == "swap" ] && VMDISKNAME=swap
        
        # build the list we parsing with ansible (jinja)
        if [ -z "${DISK_LIST['all']}" ];then
            DISK_LIST['all']+="[${VMHOST},${VMDISKNAME},${!VMDISKSIZEGB},${!VMDISKTYPE},${!VMDISKEXTRANAME},${!VMDISKDEVAUTODEL},${!VMDISKDEVBOOT}]"
        else
            DISK_LIST['all']+=",[${VMHOST},${VMDISKNAME},${!VMDISKSIZEGB},${!VMDISKTYPE},${!VMDISKEXTRANAME},${!VMDISKDEVAUTODEL},${!VMDISKDEVBOOT}]"
        fi
    done
    DISK_LIST_FLAT="${DISK_LIST['all']}"
    F_LOG $FUNCNAME "DISK_LIST:\n${DISK_LIST['all']}"

    #F_A2BIN $HOSTFILE $PBGCPDEPLOY "Deploying $VMHOST to GCP ..." "--limit pors_server -e {'project_name':'$VM_GOOGLECP_ID','server_hostname':'${VMHOSTF}','server_shortname':'${VMHOST}','server_ram_mb':'$VMRAM_MB','server_cpu_cores_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','server_machine_type':'$VM_GOOGLECP_MTYPE','server_metadata_role':'$VM_GOOGLECP_MROLE','server_disk_type':'${VMDISK1TYPE}','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${VMDISK1SIZEGB}','server_disk_dev':'${VMDISK1DEV}','server_disk_name':'$VMDISK1NAME','server_disk_gcpdevname':'$VMDISK1EXTRANAME','server_disk_autodel':'$VMDISK1DEVAUTODEL','disks':[${DISK_LIST_FLAT}],'server_disk_bootdev':'${VMDISK1DEVBOOT}'}"
    DEPERR=$?

    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"
    F_DIAERR $DEPERR "Deploying $VMHOST to $VM_GOOGLECP_ID"
    [ $DEPERR -ne 0 ] && return 99

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # format all specified disks
        F_FORMATDISK $TMPHWPROFILE
        LERR=$?
        [ $LERR -ne 0 ] && F_ERRLOG $LERR "issue occured while formatting disk(s)" $LOG && return $LERR
    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_PROXMOX_DEPLOY()
## @brief Deploys a system to Proxmox VE
## @param1 required: source file containing the hw config
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_PROXMOX_DEPLOY(){ 
    F_LOG $FUNCNAME started

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nPORS is about to provision a VM with the following details:\n\n    Proxmox Node:"$'\t'"\Zb$VM_PROXMOX_NODE\ZB\n\n    Hostname:"$'\t\t'"${VMHOSTF}\n    CPU:"$'\t\t'"$VMCPU\n    RAM:"$'\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t'"$VMIP/$VMNETMASK\n    Gateway:"$'\t\t'"$VMGW\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n    Network:"$'\t\t'"$VCNET\n\nDo you want to continue?\n" 30 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4

    F_LOG $FUNCNAME "Will start provisionining with: $PBPVEDEPLOY -e {'px_var':'$VM_PROXMOX_NODE','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM_MB','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS', 'server_scnd_disk':'$VMDISK','server_disk_type':'$VMDISKTYPE','server_disk_sizegb':'$VMDISKSIZEGB'}"


    F_A2BIN $HOSTFILE $PBPVEDEPLOY "Deploying $VMHOST to $VCHOST ..." "--limit pors_server -e {'px_var':'$VM_PROXMOX_NODE','server_hostname':['${VMHOSTF}'],'server_ram_mb':'$VMRAM_MB','server_cpu_cores_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS','server_scnd_disk':'$VMDISK'}" 
#2>&1 >> $LOG
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"
    F_DIAERR $DEPERR "Deploying $VMHOST to $VM_PROXMOX_NODE" 
    [ $DEPERR -ne 0 ] && return 99

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # add as many disk(s) as needed
        F_ADDDISK $TMPHWPROFILE 1
        LERR=$?
        [ $LERR -ne 0 ] && F_ERRLOG $LERR "issue occured while adding disk(s)" $LOG && return $LERR

        # format all specified disks
        F_FORMATDISK $TMPHWPROFILE 1
        LERR=$?
        [ $LERR -ne 0 ] && F_ERRLOG $LERR "issue occured while formatting disk(s)" $LOG && return $LERR
   else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_FORMATDISK()
## @brief Formats a new added disk of a system
## @param1 required: source file containing the hw config
## @param2 optional: skip count (e.g. 1 means start from the 2nd disk or 2 means start from the 3rd ..)
## @exception Fail: when disk is formatted already
## @details Will format all disks specified in the given PORS hardware config
## Formatting new disk(s) in an existing system must ensure that param1 is
## containing just the new disk(s) or that VMDISKFS=skip is set for any existing one
F_FORMATDISK(){
    F_LOG $FUNCNAME started
    unset VMDISKCNT

    VMDISKCNT="$2"

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    [ -z "$VMDISKCNT" ] && VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))
        F_LOG $FUNCNAME ".. parsing disk $VMDISKCNT"
            
        # dynamic variable names..
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
        VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
 
        # first check if we should skip this disk
        [ "${!VMDISKFS}" == "skip" ] && F_LOG "$FUNCNAME" "Will NOT format ${!VMDISKDEV} because 'skip' parameter has been set (VMDISKFS=${!VMDISKFS})" && continue

        if [ -z "$VMDISKLVMLV" ]||[ "$VMDISKLVMLV" == "VMDISK${VMDISKCNT}LVMLV" ];then
            F_LOG "$FUNCNAME" "Will configure without LVM.."
            F_A2BIN $HOSTFILE $PBSYSDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}'}"
        else
            F_LOG "$FUNCNAME" "Will configure with LVM.."
            F_A2BIN $HOSTFILE $PBSYSDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}','server_lvm_vg':'${!VMDISKLVMVG}','server_lvm_lv':'${!VMDISKLVMLV}'}"
        fi
        ERR=$?
        [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR    
    done
 
    F_LOG $FUNCNAME ended
}

## @fn F_ADDDISK()
## @brief Add a new disk to a system
## @param1 required: source file containing the hw config
## @param2 optional: skip count (e.g. 1 means start from the 2nd disk or 2 means start from the 3rd ..)
## @exception TODO
## @details Will add all disks specified in the given PORS hardware config
## Adding a new single disk to an existing system must ensure that param1 is
## containing just the new disk
F_ADDDISK(){
    F_LOG $FUNCNAME started

    unset VMDISKCNT

    VMDISKCNT="$2"

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # set specific variables based on which provider is used
    case $VM_PROVIDER in
        googlecp|gcp)
            F_LOG $FUNCNAME "ERROR: >$VM_PROVIDER< does not support adding disks to an existing instance (yet?)" ; return 3  ;;
        proxmox|pve)
            PROVIDERVARS="'px_var':'$VM_PROXMOX_NODE'"
            PROVPB=$PBPVENEWDISK
        ;;
        vsphere|vmware)
            PROVIDERVARS="'vsphere_esx_host':'$VM_VSPHERE_ESX','vsphere_datacenter':'$VM_VSPHERE_DC','vsphere_datastore':'$VM_VSPHERE_DS','server_scsi_controller':'$VMSCSI'"
            PROVPB=$PBVMNEWDISK
        ;;
        *) F_LOG $FUNCNAME "ERROR: >$VM_PROVIDER< is not supported!" ; return 3  ;;
    esac

    FPROVIDERVARS=$(echo "\ZbProvider\ZB\n----------\n$PROVIDERVARS" | sed 's/,/\\n/g' |tr -d "'")

    [ -z "$VMDISKCNT" ] && VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))

            # dynamic variable names..
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"
            VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"
            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

            # gen disk name from mnt point
            VMDISKNAME=$(echo "${!VMDISKMNTP}" | sed 's/.*\///g')
            [ -z "$VMDISKNAME" ] && VMDISKNAME=$(echo "${!VMDISKDEV}" | sed 's/.*\///g')

            F_LOG $FUNCNAME "VMDISKNAME: $VMDISKNAME"
            F_LOG $FUNCNAME "VMDISKLVMLV: $VMDISKLVMLV"
            F_LOG $FUNCNAME "PROVIDERVARS: $PROVIDERVARS"

            # sum up (makes uses of real tab spaces in dialog):
            if [ -z "$VMDISKLVMLV" ]||[ "$VMDISKLVMLV" == "VMDISK${VMDISKCNT}LVMLV" ];then
                F_DIALOG --no-collapse --colors --yesno "\nPORS is about to add a new disk to a system with the following details:\n\n    Target:"$'\t\t'"\Zb$VMHOSTF\ZB\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM: "$'\t'"NO\n\nDo you want to continue?\n" 50 80
            else
                F_DIALOG --no-collapse --colors --yesno "\nPORS is about to add a new disk to a system with the following details:\n\n    Target:"$'\t\t'"\Zb$VMHOSTF\ZB\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM VG name: "$'\t'"${!VMDISKLVMVG}\n    LVM LV name: "$'\t'"${!VMDISKLVMLV}\n\nDo you want to continue?\n" 50 80
            fi
            DEPLOYIT=$?
            [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 99

            F_LOG $FUNCNAME "additional disk config needed. disks left: $VMDISK"

            F_A2BIN $HOSTFILE $PROVPB "Adding a new disk to $VMHOST ..." "--limit ${VMHOSTF} -e {$PROVIDERVARS,'server_hostname':'$VMHOSTF','server_shortname':'${VMHOST}','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}','server_disk_name':'${VMDISKNAME}','server_disk_bootdev':'${!VMDISKDEVBOOT}'}"
            ADDERR=$?
            [ $ADDERR -ne 0 ] && F_LOG $FUNCNAME "error $ADDERR occured" && return $ADDERR

            F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))" 
    done
 
    F_LOG $FUNCNAME ended
}

## @fn F_BASEINSTALL()
## @brief Doing/Ensure the base is as we want it
## @exception ..
## @details This prepares or installs basic stuff we need on every system 
## as we are using a barebone template to deploy
F_BASEINSTALL(){
    F_LOG $FUNCNAME started
    GHOST="$1"
    unset AUTOMODE PARENTPID
    export PARENTPID=$BASHPID
    AUTOMODE="$1"

    if [ -z "$AUTOMODE" ];then
        SELHOSTS="$(F_SELHOST)"
        [ "$SELHOSTS" == ABORTED ] && return 4
            CREDS=$(F_GETAPICREDS)
            SPLUSR="${CREDS/:*}"
            SPLPW="${CREDS/*:}"
    else
        SELHOSTS="$AUTOMODE"
    fi

    F_LOG $FUNCNAME "selected hosts for upgrade: $SELHOSTS"

    [ -z "$SELHOSTS" ] && F_DIAERR 9 "missing param for $FUNCNAME" && break 99

    for uhost in $(echo "$SELHOSTS" |tr " " "\n" | cut -d ":" -f 1);do
        # check ssh first
        F_CHECKSSH "$uhost"
        F_A2BIN $HOSTFILE $PBBASEINSTALL "Installing base on $uhost ..." "--limit $uhost" || break
    done
    F_DIAERR $? "Base install on:\n\n$SELHOSTS\n\n"

    F_LOG $FUNCNAME ended
}

## @fn F_SYSUPGRADE()
## @brief system upgrade tasks
## @exception ..
## @details N/A
F_SYSUPGRADE(){ 
    F_LOG $FUNCNAME started
    GHOST="$1"
    unset AUTOMODE PARENTPID
    export PARENTPID=$BASHPID
    AUTOMODE="$1"

    if [ -z "$AUTOMODE" ];then
        SELHOSTS="$(F_SELHOST)"
        [ "$SELHOSTS" == ABORTED ] && return 4
            CREDS=$(F_GETAPICREDS)
            SPLUSR="${CREDS/:*}"
            SPLPW="${CREDS/*:}"
    else
        SELHOSTS="$AUTOMODE"
    fi

    F_LOG $FUNCNAME "selected hosts for upgrade: $SELHOSTS"

    [ -z "$SELHOSTS" ] && F_DIAERR 9 "missing param for $FUNCNAME" && break 99

    for uhost in $(echo "$SELHOSTS" |tr " " "\n" | cut -d ":" -f 1);do
        # check ssh first
        F_CHECKSSH "$uhost"
        F_A2BIN $HOSTFILE $PBSYSUPGRADE "Upgrading $uhost ..." "--limit $uhost" || break
    done
    FORERR=$?
    if [ $FORERR -eq 0 ];then
        F_DIALOG --scrollbar --yesno "\n\nThis server requires a reboot!\n\nDo you want to initiate a reboot now?\n(additional confirmation on next screen)" 30 50
        if [ $? -eq 0 ];then
            F_LOG $FUNCNAME "System Upgrade(s) installed for:\n$SELHOSTS\n\nA REBOOT IS REQUIRED!\nReboot handler will be initiated ..."
            F_SYSREBOOT "$SELHOSTS"
            LASTERR=$?
        else
            F_LOG $FUNCNAME "Rebooting handling skipped by user"
        fi
    else
        LASTERR=$FORERR
    fi
    F_LOG $FUNCNAME ended with $LASTERR
    return $LASTERR
}

## @fn F_SYSREBOOT()
## @brief reboots a remote system
## @param 1 required: the host or a list of hosts (space separated) to be rebooted
## @details tbd
F_SYSREBOOT(){ 
    REBHOSTS="$1"
    F_LOG $FUNCNAME "started with $REBHOSTS"
    [ -z "$REBHOSTS" ] && F_LOG $FUNCNAME "ERROR: no host given" && return 3


    for host in $REBHOSTS;do
        honly=${host/:*}
        F_DIALOG --scrollbar --yesno "\n\nDo you want to reboot $honly NOW?" 30 50
        if [ $? -eq 0 ];then
            F_A2BIN $HOSTFILE $PBSYSREBOOT "Rebooting $honly ..." "-e {'target':'$honly'}" || break
        else
            F_LOG "$FUNCNAME" "Skipped rebooting $honly"
        fi
    done
    FORERR=$?
    F_LOG $FUNCNAME ended with $FORERR
    return $FORERR
}

## @fn F_CHECKSSH()
## @brief system upgrade tasks
## @param 1 required: the host from the inventory to be checked
## @param 2 optional: the full path to another hostfile
## @details tbd
F_CHECKSSH(){ 
    F_LOG $FUNCNAME started

    CHOST="$1"
    DHOSTF="$2"

    [ -z "$CHOST" ] && F_DIAERR 9 "missing arg in $FUNCNAME" && break 99
    [ -z "$DHOSTF" ] && DHOSTF="$HOSTFILE"

    F_A2BIN $HOSTFILE $PBSSHCHK "checking $CHOST ..." "--limit $CHOST"

    F_LOG $FUNCNAME ended
}

## @fn F_MENUMAIN()
## @brief the main menu window of PORS in regular mode
F_MENUMAIN(){
    F_HOSTFILE
    F_VAULTPW
	MENUDONE=0
 	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
			--menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
			37 86 35 \
			'' '\Zb\ZuAPPS\ZB\ZU'\
			"" "" \
			Link-app "Link an app (local file or git project) to a group" \
			Deploy-apps "Deploy linked apps for a target group" \
			Remove-app "Unlink or completely remove an app of a group" \
			Show-apps "Show all already linked apps" \
			"" "" \
			'' '\Zb\Zusystem/local/*.conf\ZB\ZU'\
			"" "" \
			Edit-SYSC "Fetch/Edit/Show/Manage remote conf files" \
			Deploy-SYSC "Deploy enabled system configs"\
			"" "" \
			'' '\Zb\ZuSPLUNK ACTIONS\ZB\ZU' \
			"" "" \
			shelper	"Upgrade/Install/Exec shelper (reload,DEP/MN/DS apply bundles)" \
			splunkd "splunk> daemon commands (restart, webrestart ,..)" \
			"" "" \
			'' '\Zb\ZuSYSTEM MAINTENANCE\ZB\ZU' \
			"" "" \
			Upgrade	"Opens a submenu with upgrade tasks" \
                        VM-Management "Deploy and manage VMs" \
			'Install (splunk)'      "splunk> on ansible-ready server(s)" \
			'Install (cribl)'	"cribl logstream-worker on ansible-ready server(s)" \
                        Configure "Configure splunk> on fresh installed splunk instances" \
			Cluster "Indexer tasks" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)

			#UpgradeCluster "Upgrade a splunk> cluster (SH / IX)" \

		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			New-app)
			;;
			Link-app)
			F_ENAPP
			;;
			Deploy-apps)
			F_DEPLOYMENU
			;;
			Remove-app)
			F_RMAPP
			;;
			Show-apps)
			SELECTION=$(F_SELECTOR)
			F_GOAPPS
			;;
			Edit-SYSC)
			F_EDITSYSC
			;;
			Pull-SYSC)
			F_PULLSYSC
			;;
			Deploy-SYSC)
			#SELECTION=$(F_SELECTOR)
			F_DEPLSYSC "$(F_SELECTOR)"
			;;
			Upgrade)
			F_UPGRADEMENU
			;;
			splunkd)
			F_SPLACT
			;;
			shelper)
			F_SHELPER
                        F_ABORTMAINMENU F_SHELPER
			;;
			gitlab)
			F_SETUP_GITLAB
			;;
			'Install (splunk)')
			F_INSTALLSPL
			;;
			'Install (cribl)')
			F_INSTALLLOGSTREAM
			;;
			Cluster)
			F_CLUSTER
			;;
                        VM-Deploy)
                        F_DEPLOYVM
                        ;;
                        Configure)
                        F_CONFMENU
                        ;;
                        VM-Management)
                        F_VMMENU
                        ;;
		esac
	     done
}

## @fn F_MENUTESTING()
## @brief the main menu window of PORS in testing mode
F_MENUTESTING(){
    F_HOSTFILE
    MENUDONE=0
    F_VAULTPW
	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nStart Playbooks-On-Rails for Splunk (PORS) \n\n\Zb\Z1TESTING AREA - TESTING AREA - TESTING AREA\Zn\n\nSelect an option:" \
			25 76 25 \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			Disable-app)
			;;
		esac
	     done

}

## @fn F_MENUADVANCED()
## @brief the main menu window of PORS in advanced mode
F_MENUADVANCED(){
	while [ "$MENUDONE" == "0" ]; do
                SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
                        --menu "\nStart \Playbooks-On-Rails for Splunk (PORS)n\n\Zb\Z1ADVANCED AREA - ADVANCED AREA - ADVANCED AREA\Zn\n\nSelect an option:" \
                        20 76 20 \
                        ______________ "ADVANCED (no daily business)  ______________" \
                        "" "" \
                        Pull-SYSC "Fetch config for a target (if Edit-SYSC fails)"\
                        gitlab  "(Re-)Initialize gitlab server authentication"\
                        3>&1 1>&2 2>&3)
                if [ "$?" != "0" ]; then
                    MENUDONE=1
                    echo "$0: finished."
		    F_EXIT
                fi
                case "$SELECTION" in
                        Pull-SYSC)
                        F_PULLSYSC
                        ;;
                        gitlab)
                        F_SETUP_GITLAB
                        ;;
                esac
	done	
}

# ugly but efficient
echo "$@" | egrep -q "help"
[ $? -eq 0 ]&& F_HELP && F_EXITUNCLEAN

# ensure we know the real user and deny starting PORS directly as SPLUSER or ROOT user
ME=$(id -un)
DENYSTART=0
if [ "$ME" == "$AEUSER" -a -z "$CALLUSR" ];then
    DENYSTART=1
else
    [ "$ME" == "root" ] && DENYSTART=1
fi
[ $DENYSTART -eq 1 ] && echo -e "\n\nERROR: Starting PORS as user $ME has been denied.\nPORS must be started as your REAL user since v2.3!\n\nSo .. login as your regular user and try again\n\n" && F_EXIT

if [ "$ME" != "$AEUSER" ] || [ -z "$CALLUSR" ];then
    echo "Thanks for choosing PORS $ME, starting PORS now ($@) ..."
    sudo -u $AEUSER /usr/bin/env CALLUSR=$ME $0 $@
    F_EXITUNCLEAN $?
fi

echo "starting PORS as user $ME"

# pre-check Ansible reqs
# check ansible version first
unset AVERSF AVERS A2VERSF A2VERS
MREQAVERSION=$(echo $REQAVERSION |tr -d ".")
AVERSF=$($ABIN --version | head -n 1 | egrep -o "[1-9]+\.[0-9]+\.[0-9]+")
AVERS=$(echo $AVERSF | tr -d ".")
[ -f "$A2BIN" ] && A2VERSF=$(F_A2BIN version |head -n 1 | egrep -o "[1-9]+\.[0-9]+\.[0-9]+") && A2VERS=$(echo $A2VERSF | tr -d ".")
F_LOG MAIN "Detected Ansible version(s):\nAVERS: $AVERS\nA2VERS: $A2VERS\nMin required: $MREQAVERSION"

if [ -z "$A2VERS" ];then
   [ "$AVERS" -lt "$MREQAVERSION" ] && F_DIAERR 999 "No suitable Ansible version found!!!\nRequired: $REQAVERSION\nFound: $AVERSF" && F_EXIT
    export MAXAVERSION=$AVERSF
else
   [ "$A2VERS" -lt "$MREQAVERSION" ] && F_DIAERR 999 "No suitable Ansible version found!!!\nRequired: $REQAVERSION\nFound: $A2VERSF" && F_EXIT
    export MAXAVERSION=$A2VERSF
fi

cd $ADIR
 
echo "$@" |egrep -q "(noninteractive|batch)"
if [ $? -eq 0 ];then
   # enter non-interactive/batch mode
    export LOG=$WORKDIR/${BIN}_batchmode.log
    F_LOGROTATE
    # reset any previous set user host file
    > $AEUSRHOSTFILE

    export RUNMODE=batch
    export BDEPAPPSUBSET=0
    unset BATCHACT

    # parse args
    while [ ! -z "$1" ];do
        case "$1" in
	    -1) BABIN=$ABIN ;shift;;
            --batch|--noninteractive) shift;;
	    -p|--play) BPLAY="$2"; shift 2;;
	    --playargs) BPLAYARGS="$2"; shift 2;;
            -F|--function|--func) BFUNC="$?"; shift 2;;
            --funcargs) BFUNCARGS="$?"; shift 2;;
            -a|--action) BACT="$2"; shift 2;;
	    -t|--target) BTARGET="$2"; shift 2;;
            -i|--inventory) export HOSTFILE="$2"; export SHOSTFILE="$HOSTFILE"; FORCEDHOSTFILE="$2"; shift 2;;
            --env) TARGETENV=$2; shift 2 ;;
            --deployapp)
            export BDEPAPP="$2"
            export BDEPAPPSUBSET=1
            shift 2
            ;;
            --vault-password-file)
            declare VAULTTEMPFILE="$2"
            shift 2
            [ ! -f $VAULTTEMPFILE ] && F_LOG MAIN "ERROR: $VAULTTEMPFILE does not exist!" \
                && echo "ERROR: $VAULTTEMPFILE does not exist!" \
                && F_EXIT 99
            unset A2VAULTARG
            declare A2VAULTARG="--vault-password-file $VAULTTEMPFILE"
            declare ABIN="$ABIN ${A2VAULTARG}"
            declare VBINX=$VBIN
            declare VBIN="$VBIN ${A2VAULTARG}"
            echo "$ABIN, $VBIN"
            ;;
            -pa|--post-action)
            export BATCHACT="$2"
            shift 2
            ;;
	    *) echo -e "ERROR unknown argument: $1\n"; F_EXIT ;;
        esac
    done
   # validate args
   for f in $HOSTFILE $BPLAY; do
	if [ ! -f $f ];then
	  echo "ERROR missing file: >$f<"
	  F_EXIT
	fi
   done
   [ -z "$BTARGET" -o -z "$HOSTFILE" ] && echo -e "ERROR: missing a required arg\n(target:$BTARGET,hosts:$HOSTFILE)!" && F_EXIT 
   [ -z "$BACT" -a -z "$BPLAY" ] && echo -e "ERROR: Either action or play must be defined (action: $BACT, play: $BPLAY)!" && F_EXIT

    ## @var EXECBIT
    ## @brief execution lock file based on the target environment
    ## @showinitializer
    ## @details A simple lock file to detect an already running PORS session.
    ## Makes use of the selected environment so you are able to run e.g. prod and dev the same time
    declare EXECBIT=/tmp/.pors_batch_${TARGETENV}.lock

   # detect running session and kill/ask
   [ -f $EXECBIT ] && echo -e "\n\nWARNING: It seems PORS is already running by user: $(cat $EXECBIT)! ABORTED!" && F_LOG "$BIN" "PORS is already running by $(cat $EXECBIT). ABORTED!" && exit 99
    echo "$CALLUSR" > $EXECBIT && chmod o+w $EXECBIT

    ## @var PORS_TEMPDIR
    ## @brief Temporary directory defined within ansible config
    ## @details ..
    ## @showinitializer
    declare PORS_TEMPDIR=$(grep pors_temp_dir $AINVENTORY/$TARGETENV/group_vars/all/pors.yml | cut -d ":" -f 2)

   # run
    if [ "$BPLAY" ];then
        F_LOG MAIN "$ABIN -i $HOSTFILE $BPLAY -e \"target=$BTARGET accept_hostkey=true $BPLAYARGS\""
        $ABIN -i $HOSTFILE $BPLAY -e "target=$BTARGET accept_hostkey=true $BPLAYARGS" -vvvv
    else
        if [ "$BFUNC" ];then
            F_LOG MAIN ".. will exec $BFUNC. Args: $BFUNCARGS"
            $BFUNC $BFUNCARGS
        else
            case $BACT in
                deploy)
                export DEPLOYAPPSUBSET=$BDEPAPPSUBSET 
                F_DEPLOYAPP
                DEPERR=$?
                [ $DEPERR -ne 0 ] && F_LOG MAIN "deploying ended with $DEPERR" && F_EXIT $DEPERR
                [ ! -z $"BATCHACT" ] && F_LOG "$BIN" "activating changes..." && F_SHEXEC
                ;;
                *)
                echo "ERROR: Action $BACT does not exists!"
                exit 3
                ;;
            esac
        fi
    fi
else
    unset A2VAULTARG
    [ "$ENABLEVAULT" == "yes" ] \
    && declare A2VAULTARG="--vault-password-file $VAULTTEMPFILE" \
    && declare ABIN="$ABIN ${A2VAULTARG}" \
    && declare VBINX=$VBIN \
    && declare VBIN="$VBIN ${A2VAULTARG}"

    # interactive mode
    MENUDONE=0
    F_LOGROTATE
    # reset any previously set user host file
    > $AEUSRHOSTFILE

    while [ ! -z "$1" ]; do
      case "$1" in
	--advanced)
	MAINMENU=F_MENUADVANCED
	shift
	;;
	--testing)
	MAINMENU=F_MENUTESTING
	shift
	;;
	--env)
	export TARGETENV=$2
	shift 2
	;;
        -i|--inventory)
        export FORCEDHOSTFILE="$2"
        shift 2
        ;;
        --stealth)
        export STEALTHMODE=1
        shift
        ;;
	*)
	F_HELP
	F_EXIT
	;;
      esac
    done
    # support multiple environments
    while [ -z "$TARGETENV" ];do
	TARGETENV=$(F_CHOOSEENV)
        [ "$TARGETENV" == "ABORTED" ] && F_EXIT
    done

    [ ! -d "$AINVENTORY/$TARGETENV" ] && echo -e "\nERROR: specified environment $TARGETENV\n($AINVENTORY/$TARGETENV)\ndoes not exist!" && F_HELP && F_EXIT

    ## @var EXECBIT
    ## @brief execution lock file based on the target environment
    ## @showinitializer
    ## @details A simple lock file to detect an already running PORS session.
    ## Makes use of the selected environment so you are able to run e.g. prod and dev the same time
    declare EXECBIT=/tmp/.pors_${TARGETENV}.lock

    # detect running session and kill/ask
    if [ -z "$STEALTHMODE" ];then
        NONE='\033[00m'
        RED='\033[01;31m'
        [ -f "$EXECBIT" ] && echo -e "\n\t${RED}WARNING - WARNING\n\t-----------------------${NONE}\n\n\tIt seems PORS is already opened by \n\n${RED}\t\t>  $(cat $EXECBIT)  <${NONE}\n\n\tBEFORE you choose overwriting the lock ${RED}contact the above user!${NONE}\n\tPORS does not support working in parallel so this WILL break things if you try to proceed while another user is actively working!\n\n" && read -p "....... do you want ME to override, delete the execbit and continue anyways (no risk no fun heh?)? (y/N)" KICKUSER
        echo KICK: $KICKUSER
        [ -f "$EXECBIT" ]&&[ "$KICKUSER" != "y" ] && F_EXITUNCLEAN
        echo "$CALLUSR" > $EXECBIT && chmod 777 $EXECBIT
    else
        F_LOG START "running in STEALTH MODE!!!"
        declare LOG="${WORKDIR}/${BIN}-stealthmode.log"
    fi

    ## @var DEFAULTVAULT
    ## @brief full path to the default vault
    ## @details This is used to check the typed password so it must exists (if using ENABLEVAULT=yes)
    ## @showinitializer
    declare DEFAULTVAULT=$AINVENTORY/$TARGETENV/group_vars/all/vault.yml

    ## @var PORS_TEMPDIR
    ## @brief Temporary directory defined within ansible config
    ## @details ..
    ## @showinitializer
    declare PORS_TEMPDIR=$(grep pors_temp_dir $AINVENTORY/$TARGETENV/group_vars/all/pors.yml | cut -d ":" -f 2)

    [ -z "$MAINMENU" ]&& MAINMENU=F_MENUMAIN
    $MAINMENU
fi

F_EXIT
